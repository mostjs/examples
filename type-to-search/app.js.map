{"version":3,"file":"app.js","sources":["../node_modules/@most/prelude/dist/index.es.js","../node_modules/@most/scheduler/dist/index.es.js","../node_modules/@most/core/dist/index.es.js","../node_modules/@most/dom-event/dist/index.es.js","../node_modules/most-product/node_modules/@most/core/dist/index.es.js","../node_modules/most-product/dist/index.es.js","../node_modules/rest/util/mixin.js","../node_modules/rest/mime/type/application/x-www-form-urlencoded.js","../node_modules/rest/UrlBuilder.js","../node_modules/rest/util/normalizeHeaderName.js","../node_modules/rest/util/responsePromise.js","../node_modules/rest/client.js","../node_modules/rest/client/jsonp.js","index.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\n// Non-mutating array operations\n\n// cons :: a -> [a] -> [a]\n// a with x prepended\nfunction cons(x, a) {\n  var l = a.length;\n  var b = new Array(l + 1);\n  b[0] = x;\n  for (var i = 0; i < l; ++i) {\n    b[i + 1] = a[i];\n  }\n  return b;\n}\n\n// append :: a -> [a] -> [a]\n// a with x appended\nfunction append(x, a) {\n  var l = a.length;\n  var b = new Array(l + 1);\n  for (var i = 0; i < l; ++i) {\n    b[i] = a[i];\n  }\n\n  b[l] = x;\n  return b;\n}\n\n// drop :: Int -> [a] -> [a]\n// drop first n elements\nfunction drop(n, a) {\n  // eslint-disable-line complexity\n  if (n < 0) {\n    throw new TypeError('n must be >= 0');\n  }\n\n  var l = a.length;\n  if (n === 0 || l === 0) {\n    return a;\n  }\n\n  if (n >= l) {\n    return [];\n  }\n\n  return unsafeDrop(n, a, l - n);\n}\n\n// unsafeDrop :: Int -> [a] -> Int -> [a]\n// Internal helper for drop\nfunction unsafeDrop(n, a, l) {\n  var b = new Array(l);\n  for (var i = 0; i < l; ++i) {\n    b[i] = a[n + i];\n  }\n  return b;\n}\n\n// tail :: [a] -> [a]\n// drop head element\nfunction tail(a) {\n  return drop(1, a);\n}\n\n// copy :: [a] -> [a]\n// duplicate a (shallow duplication)\nfunction copy(a) {\n  var l = a.length;\n  var b = new Array(l);\n  for (var i = 0; i < l; ++i) {\n    b[i] = a[i];\n  }\n  return b;\n}\n\n// map :: (a -> b) -> [a] -> [b]\n// transform each element with f\nfunction map(f, a) {\n  var l = a.length;\n  var b = new Array(l);\n  for (var i = 0; i < l; ++i) {\n    b[i] = f(a[i]);\n  }\n  return b;\n}\n\n// reduce :: (a -> b -> a) -> a -> [b] -> a\n// accumulate via left-fold\nfunction reduce(f, z, a) {\n  var r = z;\n  for (var i = 0, l = a.length; i < l; ++i) {\n    r = f(r, a[i], i);\n  }\n  return r;\n}\n\n// replace :: a -> Int -> [a]\n// replace element at index\nfunction replace(x, i, a) {\n  // eslint-disable-line complexity\n  if (i < 0) {\n    throw new TypeError('i must be >= 0');\n  }\n\n  var l = a.length;\n  var b = new Array(l);\n  for (var j = 0; j < l; ++j) {\n    b[j] = i === j ? x : a[j];\n  }\n  return b;\n}\n\n// remove :: Int -> [a] -> [a]\n// remove element at index\nfunction remove(i, a) {\n  // eslint-disable-line complexity\n  if (i < 0) {\n    throw new TypeError('i must be >= 0');\n  }\n\n  var l = a.length;\n  if (l === 0 || i >= l) {\n    // exit early if index beyond end of array\n    return a;\n  }\n\n  if (l === 1) {\n    // exit early if index in bounds and length === 1\n    return [];\n  }\n\n  return unsafeRemove(i, a, l - 1);\n}\n\n// unsafeRemove :: Int -> [a] -> Int -> [a]\n// Internal helper to remove element at index\nfunction unsafeRemove(i, a, l) {\n  var b = new Array(l);\n  var j = void 0;\n  for (j = 0; j < i; ++j) {\n    b[j] = a[j];\n  }\n  for (j = i; j < l; ++j) {\n    b[j] = a[j + 1];\n  }\n\n  return b;\n}\n\n// removeAll :: (a -> boolean) -> [a] -> [a]\n// remove all elements matching a predicate\nfunction removeAll(f, a) {\n  var l = a.length;\n  var b = new Array(l);\n  var j = 0;\n  for (var x, i = 0; i < l; ++i) {\n    x = a[i];\n    if (!f(x)) {\n      b[j] = x;\n      ++j;\n    }\n  }\n\n  b.length = j;\n  return b;\n}\n\n// findIndex :: a -> [a] -> Int\n// find index of x in a, from the left\nfunction findIndex(x, a) {\n  for (var i = 0, l = a.length; i < l; ++i) {\n    if (x === a[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// isArrayLike :: * -> boolean\n// Return true iff x is array-like\nfunction isArrayLike(x) {\n  return x != null && typeof x.length === 'number' && typeof x !== 'function';\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\n// id :: a -> a\nvar id = function id(x) {\n  return x;\n};\n\n// compose :: (b -> c) -> (a -> b) -> (a -> c)\nvar compose = function compose(f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n};\n\n// apply :: (a -> b) -> a -> b\nvar apply = function apply(f, x) {\n  return f(x);\n};\n\n// curry2 :: ((a, b) -> c) -> (a -> b -> c)\nfunction curry2(f) {\n  function curried(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return curried;\n      case 1:\n        return function (b) {\n          return f(a, b);\n        };\n      default:\n        return f(a, b);\n    }\n  }\n  return curried;\n}\n\n// curry3 :: ((a, b, c) -> d) -> (a -> b -> c -> d)\nfunction curry3(f) {\n  function curried(a, b, c) {\n    // eslint-disable-line complexity\n    switch (arguments.length) {\n      case 0:\n        return curried;\n      case 1:\n        return curry2(function (b, c) {\n          return f(a, b, c);\n        });\n      case 2:\n        return function (c) {\n          return f(a, b, c);\n        };\n      default:\n        return f(a, b, c);\n    }\n  }\n  return curried;\n}\n\n// curry4 :: ((a, b, c, d) -> e) -> (a -> b -> c -> d -> e)\nfunction curry4(f) {\n  function curried(a, b, c, d) {\n    // eslint-disable-line complexity\n    switch (arguments.length) {\n      case 0:\n        return curried;\n      case 1:\n        return curry3(function (b, c, d) {\n          return f(a, b, c, d);\n        });\n      case 2:\n        return curry2(function (c, d) {\n          return f(a, b, c, d);\n        });\n      case 3:\n        return function (d) {\n          return f(a, b, c, d);\n        };\n      default:\n        return f(a, b, c, d);\n    }\n  }\n  return curried;\n}\n\n/** @license MIT License (c) copyright 2016 original author or authors */\n\nexport { cons, append, drop, tail, copy, map, reduce, replace, remove, removeAll, findIndex, isArrayLike, id, compose, apply, curry2, curry3, curry4 };\n//# sourceMappingURL=index.es.js.map\n","import { curry2, curry3, findIndex, removeAll } from '@most/prelude';\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar ScheduledTask = /*#__PURE__*/function () {\n  function ScheduledTask(time, localOffset, period, task, scheduler) {\n    classCallCheck(this, ScheduledTask);\n\n    this.time = time;\n    this.localOffset = localOffset;\n    this.period = period;\n    this.task = task;\n    this.scheduler = scheduler;\n    this.active = true;\n  }\n\n  ScheduledTask.prototype.run = function run() {\n    return this.task.run(this.time - this.localOffset);\n  };\n\n  ScheduledTask.prototype.error = function error(e) {\n    return this.task.error(this.time - this.localOffset, e);\n  };\n\n  ScheduledTask.prototype.dispose = function dispose() {\n    this.scheduler.cancel(this);\n    return this.task.dispose();\n  };\n\n  return ScheduledTask;\n}();\n\nvar RelativeScheduler = /*#__PURE__*/function () {\n  function RelativeScheduler(origin, scheduler) {\n    classCallCheck(this, RelativeScheduler);\n\n    this.origin = origin;\n    this.scheduler = scheduler;\n  }\n\n  RelativeScheduler.prototype.currentTime = function currentTime() {\n    return this.scheduler.currentTime() - this.origin;\n  };\n\n  RelativeScheduler.prototype.scheduleTask = function scheduleTask(localOffset, delay, period, task) {\n    return this.scheduler.scheduleTask(localOffset + this.origin, delay, period, task);\n  };\n\n  RelativeScheduler.prototype.relative = function relative(origin) {\n    return new RelativeScheduler(origin + this.origin, this.scheduler);\n  };\n\n  RelativeScheduler.prototype.cancel = function cancel(task) {\n    return this.scheduler.cancel(task);\n  };\n\n  RelativeScheduler.prototype.cancelAll = function cancelAll(f) {\n    return this.scheduler.cancelAll(f);\n  };\n\n  return RelativeScheduler;\n}();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar defer = function defer(task) {\n  return Promise.resolve(task).then(runTask);\n};\n\nfunction runTask(task) {\n  try {\n    return task.run();\n  } catch (e) {\n    return task.error(e);\n  }\n}\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar Scheduler = /*#__PURE__*/function () {\n  function Scheduler(timer, timeline) {\n    var _this = this;\n\n    classCallCheck(this, Scheduler);\n\n    this.timer = timer;\n    this.timeline = timeline;\n\n    this._timer = null;\n    this._nextArrival = Infinity;\n\n    this._runReadyTasksBound = function () {\n      return _this._runReadyTasks(_this.currentTime());\n    };\n  }\n\n  Scheduler.prototype.currentTime = function currentTime() {\n    return this.timer.now();\n  };\n\n  Scheduler.prototype.scheduleTask = function scheduleTask(localOffset, delay, period, task) {\n    var time = this.currentTime() + Math.max(0, delay);\n    var st = new ScheduledTask(time, localOffset, period, task, this);\n\n    this.timeline.add(st);\n    this._scheduleNextRun();\n    return st;\n  };\n\n  Scheduler.prototype.relative = function relative(offset) {\n    return new RelativeScheduler(offset, this);\n  };\n\n  Scheduler.prototype.cancel = function cancel(task) {\n    task.active = false;\n    if (this.timeline.remove(task)) {\n      this._reschedule();\n    }\n  };\n\n  Scheduler.prototype.cancelAll = function cancelAll(f) {\n    this.timeline.removeAll(f);\n    this._reschedule();\n  };\n\n  Scheduler.prototype._reschedule = function _reschedule() {\n    if (this.timeline.isEmpty()) {\n      this._unschedule();\n    } else {\n      this._scheduleNextRun(this.currentTime());\n    }\n  };\n\n  Scheduler.prototype._unschedule = function _unschedule() {\n    this.timer.clearTimer(this._timer);\n    this._timer = null;\n  };\n\n  Scheduler.prototype._scheduleNextRun = function _scheduleNextRun() {\n    // eslint-disable-line complexity\n    if (this.timeline.isEmpty()) {\n      return;\n    }\n\n    var nextArrival = this.timeline.nextArrival();\n\n    if (this._timer === null) {\n      this._scheduleNextArrival(nextArrival);\n    } else if (nextArrival < this._nextArrival) {\n      this._unschedule();\n      this._scheduleNextArrival(nextArrival);\n    }\n  };\n\n  Scheduler.prototype._scheduleNextArrival = function _scheduleNextArrival(nextArrival) {\n    this._nextArrival = nextArrival;\n    var delay = Math.max(0, nextArrival - this.currentTime());\n    this._timer = this.timer.setTimer(this._runReadyTasksBound, delay);\n  };\n\n  Scheduler.prototype._runReadyTasks = function _runReadyTasks() {\n    this._timer = null;\n    this.timeline.runTasks(this.currentTime(), runTask);\n    this._scheduleNextRun();\n  };\n\n  return Scheduler;\n}();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar Timeline = /*#__PURE__*/function () {\n  function Timeline() {\n    classCallCheck(this, Timeline);\n\n    this.tasks = [];\n  }\n\n  Timeline.prototype.nextArrival = function nextArrival() {\n    return this.isEmpty() ? Infinity : this.tasks[0].time;\n  };\n\n  Timeline.prototype.isEmpty = function isEmpty() {\n    return this.tasks.length === 0;\n  };\n\n  Timeline.prototype.add = function add(st) {\n    insertByTime(st, this.tasks);\n  };\n\n  Timeline.prototype.remove = function remove(st) {\n    var i = binarySearch(getTime(st), this.tasks);\n\n    if (i >= 0 && i < this.tasks.length) {\n      var at = findIndex(st, this.tasks[i].events);\n      if (at >= 0) {\n        this.tasks[i].events.splice(at, 1);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Timeline.prototype.removeAll = function removeAll$$1(f) {\n    for (var i = 0; i < this.tasks.length; ++i) {\n      removeAllFrom(f, this.tasks[i]);\n    }\n  };\n\n  Timeline.prototype.runTasks = function runTasks(t, runTask) {\n    var tasks = this.tasks;\n    var l = tasks.length;\n    var i = 0;\n\n    while (i < l && tasks[i].time <= t) {\n      ++i;\n    }\n\n    this.tasks = tasks.slice(i);\n\n    // Run all ready tasks\n    for (var j = 0; j < i; ++j) {\n      this.tasks = runReadyTasks(runTask, tasks[j].events, this.tasks);\n    }\n  };\n\n  return Timeline;\n}();\n\nfunction runReadyTasks(runTask, events, tasks) {\n  // eslint-disable-line complexity\n  for (var i = 0; i < events.length; ++i) {\n    var task = events[i];\n\n    if (task.active) {\n      runTask(task);\n\n      // Reschedule periodic repeating tasks\n      // Check active again, since a task may have canceled itself\n      if (task.period >= 0 && task.active) {\n        task.time = task.time + task.period;\n        insertByTime(task, tasks);\n      }\n    }\n  }\n\n  return tasks;\n}\n\nfunction insertByTime(task, timeslots) {\n  var l = timeslots.length;\n  var time = getTime(task);\n\n  if (l === 0) {\n    timeslots.push(newTimeslot(time, [task]));\n    return;\n  }\n\n  var i = binarySearch(time, timeslots);\n\n  if (i >= l) {\n    timeslots.push(newTimeslot(time, [task]));\n  } else {\n    insertAtTimeslot(task, timeslots, time, i);\n  }\n}\n\nfunction insertAtTimeslot(task, timeslots, time, i) {\n  var timeslot = timeslots[i];\n  if (time === timeslot.time) {\n    addEvent(task, timeslot.events, time);\n  } else {\n    timeslots.splice(i, 0, newTimeslot(time, [task]));\n  }\n}\n\nfunction addEvent(task, events) {\n  if (events.length === 0 || task.time >= events[events.length - 1].time) {\n    events.push(task);\n  } else {\n    spliceEvent(task, events);\n  }\n}\n\nfunction spliceEvent(task, events) {\n  for (var j = 0; j < events.length; j++) {\n    if (task.time < events[j].time) {\n      events.splice(j, 0, task);\n      break;\n    }\n  }\n}\n\nfunction getTime(scheduledTask) {\n  return Math.floor(scheduledTask.time);\n}\n\nfunction removeAllFrom(f, timeslot) {\n  timeslot.events = removeAll(f, timeslot.events);\n}\n\nfunction binarySearch(t, sortedArray) {\n  // eslint-disable-line complexity\n  var lo = 0;\n  var hi = sortedArray.length;\n  var mid = void 0,\n      y = void 0;\n\n  while (lo < hi) {\n    mid = Math.floor((lo + hi) / 2);\n    y = sortedArray[mid];\n\n    if (t === y.time) {\n      return mid;\n    } else if (t < y.time) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return hi;\n}\n\nvar newTimeslot = function newTimeslot(t, events) {\n  return { time: t, events: events };\n};\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\n/* global setTimeout, clearTimeout */\n\nvar ClockTimer = /*#__PURE__*/function () {\n  function ClockTimer(clock) {\n    classCallCheck(this, ClockTimer);\n\n    this._clock = clock;\n  }\n\n  ClockTimer.prototype.now = function now() {\n    return this._clock.now();\n  };\n\n  ClockTimer.prototype.setTimer = function setTimer(f, dt) {\n    return dt <= 0 ? runAsap(f) : setTimeout(f, dt);\n  };\n\n  ClockTimer.prototype.clearTimer = function clearTimer(t) {\n    return t instanceof Asap ? t.cancel() : clearTimeout(t);\n  };\n\n  return ClockTimer;\n}();\n\nvar Asap = /*#__PURE__*/function () {\n  function Asap(f) {\n    classCallCheck(this, Asap);\n\n    this.f = f;\n    this.active = true;\n  }\n\n  Asap.prototype.run = function run() {\n    return this.active && this.f();\n  };\n\n  Asap.prototype.error = function error(e) {\n    throw e;\n  };\n\n  Asap.prototype.cancel = function cancel() {\n    this.active = false;\n  };\n\n  return Asap;\n}();\n\nfunction runAsap(f) {\n  var task = new Asap(f);\n  defer(task);\n  return task;\n}\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\n/* global performance, process */\n\nvar RelativeClock = /*#__PURE__*/function () {\n  function RelativeClock(clock, origin) {\n    classCallCheck(this, RelativeClock);\n\n    this.origin = origin;\n    this.clock = clock;\n  }\n\n  RelativeClock.prototype.now = function now() {\n    return this.clock.now() - this.origin;\n  };\n\n  return RelativeClock;\n}();\n\nvar HRTimeClock = /*#__PURE__*/function () {\n  function HRTimeClock(hrtime, origin) {\n    classCallCheck(this, HRTimeClock);\n\n    this.origin = origin;\n    this.hrtime = hrtime;\n  }\n\n  HRTimeClock.prototype.now = function now() {\n    var hrt = this.hrtime(this.origin);\n    return (hrt[0] * 1e9 + hrt[1]) / 1e6;\n  };\n\n  return HRTimeClock;\n}();\n\nvar clockRelativeTo = function clockRelativeTo(clock) {\n  return new RelativeClock(clock, clock.now());\n};\n\nvar newPerformanceClock = function newPerformanceClock() {\n  return clockRelativeTo(performance);\n};\n\nvar newDateClock = function newDateClock() {\n  return clockRelativeTo(Date);\n};\n\nvar newHRTimeClock = function newHRTimeClock() {\n  return new HRTimeClock(process.hrtime, process.hrtime());\n};\n\nvar newPlatformClock = function newPlatformClock() {\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    return newPerformanceClock();\n  } else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n    return newHRTimeClock();\n  }\n\n  return newDateClock();\n};\n\n// Read the current time from the provided Scheduler\nvar currentTime = function currentTime(scheduler) {\n  return scheduler.currentTime();\n};\n\n// Schedule a task to run as soon as possible, but\n// not in the current call stack\nvar asap = /*#__PURE__*/curry2(function (task, scheduler) {\n  return scheduler.scheduleTask(0, 0, -1, task);\n});\n\n// Schedule a task to run after a millisecond delay\nvar delay = /*#__PURE__*/curry3(function (delay, task, scheduler) {\n  return scheduler.scheduleTask(0, delay, -1, task);\n});\n\n// Schedule a task to run periodically, with the\n// first run starting asap\nvar periodic = /*#__PURE__*/curry3(function (period, task, scheduler) {\n  return scheduler.scheduleTask(0, 0, period, task);\n});\n\n// Cancel a scheduledTask\nvar cancelTask = function cancelTask(scheduledTask) {\n  return scheduledTask.dispose();\n};\n\n// Cancel all ScheduledTasks for which a predicate\n// is true\nvar cancelAllTasks = /*#__PURE__*/curry2(function (predicate, scheduler) {\n  return scheduler.cancelAll(predicate);\n});\n\nvar schedulerRelativeTo = /*#__PURE__*/curry2(function (offset, scheduler) {\n  return new RelativeScheduler(offset, scheduler);\n});\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar newScheduler = /*#__PURE__*/curry2(function (timer, timeline) {\n  return new Scheduler(timer, timeline);\n});\n\nvar newDefaultScheduler = function newDefaultScheduler() {\n  return new Scheduler(newDefaultTimer(), new Timeline());\n};\n\nvar newDefaultTimer = function newDefaultTimer() {\n  return new ClockTimer(newPlatformClock());\n};\nvar newClockTimer = function newClockTimer(clock) {\n  return new ClockTimer(clock);\n};\n\nvar newTimeline = function newTimeline() {\n  return new Timeline();\n};\n\nexport { newScheduler, newDefaultScheduler, newDefaultTimer, newClockTimer, newTimeline, RelativeClock, HRTimeClock, clockRelativeTo, newPerformanceClock, newDateClock, newHRTimeClock, newPlatformClock, currentTime, asap, delay, periodic, cancelTask, cancelAllTasks, schedulerRelativeTo };\n//# sourceMappingURL=index.es.js.map\n","import { append, apply, compose, curry2, curry3, findIndex, id, map, reduce, remove } from '@most/prelude';\nimport { asap, cancelAllTasks, currentTime, delay, periodic, schedulerRelativeTo } from '@most/scheduler';\nimport { disposeAll, disposeBoth, disposeNone, disposeOnce, tryDispose } from '@most/disposable';\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction fatalError(e) {\n  setTimeout(rethrow, 0, e);\n}\n\nfunction rethrow(e) {\n  throw e;\n}\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar propagateTask$1 = function propagateTask(run, value, sink) {\n  return new PropagateTask(run, value, sink);\n};\n\nvar propagateEventTask$1 = function propagateEventTask(value, sink) {\n  return propagateTask$1(runEvent, value, sink);\n};\n\nvar propagateEndTask = function propagateEndTask(sink) {\n  return propagateTask$1(runEnd, undefined, sink);\n};\n\nvar propagateErrorTask$1 = function propagateErrorTask(value, sink) {\n  return propagateTask$1(runError, value, sink);\n};\n\nvar PropagateTask = /*#__PURE__*/function () {\n  function PropagateTask(run, value, sink) {\n    classCallCheck(this, PropagateTask);\n\n    this._run = run;\n    this.value = value;\n    this.sink = sink;\n    this.active = true;\n  }\n\n  PropagateTask.prototype.dispose = function dispose() {\n    this.active = false;\n  };\n\n  PropagateTask.prototype.run = function run(t) {\n    if (!this.active) {\n      return;\n    }\n    var run = this._run;\n    run(t, this.value, this.sink);\n  };\n\n  PropagateTask.prototype.error = function error(t, e) {\n    // TODO: Remove this check and just do this.sink.error(t, e)?\n    if (!this.active) {\n      return fatalError(e);\n    }\n    this.sink.error(t, e);\n  };\n\n  return PropagateTask;\n}();\n\nvar runEvent = function runEvent(t, x, sink) {\n  return sink.event(t, x);\n};\n\nvar runEnd = function runEnd(t, _, sink) {\n  return sink.end(t);\n};\n\nvar runError = function runError(t, e, sink) {\n  return sink.error(t, e);\n};\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar empty = function empty() {\n  return EMPTY;\n};\n\nvar isCanonicalEmpty = function isCanonicalEmpty(stream) {\n  return stream === EMPTY;\n};\n\nvar containsCanonicalEmpty = function containsCanonicalEmpty(streams) {\n  return streams.some(isCanonicalEmpty);\n};\n\nvar Empty = /*#__PURE__*/function () {\n  function Empty() {\n    classCallCheck(this, Empty);\n  }\n\n  Empty.prototype.run = function run(sink, scheduler$$1) {\n    return asap(propagateEndTask(sink), scheduler$$1);\n  };\n\n  return Empty;\n}();\n\nvar EMPTY = /*#__PURE__*/new Empty();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar never = function never() {\n  return NEVER;\n};\n\nvar Never = /*#__PURE__*/function () {\n  function Never() {\n    classCallCheck(this, Never);\n  }\n\n  Never.prototype.run = function run() {\n    return disposeNone();\n  };\n\n  return Never;\n}();\n\nvar NEVER = /*#__PURE__*/new Never();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar at = function at(t, x) {\n  return new At(t, x);\n};\n\nvar At = /*#__PURE__*/function () {\n  function At(t, x) {\n    classCallCheck(this, At);\n\n    this.time = t;\n    this.value = x;\n  }\n\n  At.prototype.run = function run(sink, scheduler$$1) {\n    return delay(this.time, propagateTask$1(runAt, this.value, sink), scheduler$$1);\n  };\n\n  return At;\n}();\n\nfunction runAt(t, x, sink) {\n  sink.event(t, x);\n  sink.end(t);\n}\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar now = function now(x) {\n  return at(0, x);\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Create a stream of events that occur at a regular period\n * @param {Number} period periodicity of events\n * @returns {Stream} new stream of periodic events, the event value is undefined\n */\nvar periodic$1 = function periodic$$1(period) {\n  return new Periodic(period);\n};\n\nvar Periodic = /*#__PURE__*/function () {\n  function Periodic(period) {\n    classCallCheck(this, Periodic);\n\n    this.period = period;\n  }\n\n  Periodic.prototype.run = function run(sink, scheduler$$1) {\n    return periodic(this.period, propagateEventTask$1(undefined, sink), scheduler$$1);\n  };\n\n  return Periodic;\n}();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar newStream = function newStream(run) {\n  return new Stream(run);\n};\n\nvar Stream = function Stream(run) {\n  classCallCheck(this, Stream);\n\n  this.run = run;\n};\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n/** @author Brian Cavalier */\n\nvar Pipe = /*#__PURE__*/function () {\n  function Pipe(sink) {\n    classCallCheck(this, Pipe);\n\n    this.sink = sink;\n  }\n\n  Pipe.prototype.event = function event(t, x) {\n    return this.sink.event(t, x);\n  };\n\n  Pipe.prototype.end = function end(t) {\n    return this.sink.end(t);\n  };\n\n  Pipe.prototype.error = function error(t, e) {\n    return this.sink.error(t, e);\n  };\n\n  return Pipe;\n}();\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n// A slice Bounds type that narrows min values via accumulation\n// and max values via Math.min.\n// type Bounds = { min: number, max: number }\n// Notes:\n// 0 <= min <= max\n// slice(min2, max2, slice(min1, max1, s)) ~ slice(min1 + min2, Math.min(max1, min1 + max2), s)\n// A bounds has a 1d coord system with origin 0, extending to Infinity.  Both min and max\n// are relative to the origin (0).  However, when merging bounds b1 and b2, we\n// *interpret* b2 as being relative to b1, hence adding min1 to *both* min2 and max2.\n// This essentially translates b2's coordinates back into origin coordinates\n// as bounds are merged.\n\n// Construct a constrained bounds\nvar boundsFrom = function boundsFrom(unsafeMin, unsafeMax) {\n  var min = Math.max(0, unsafeMin);\n  var max = Math.max(min, unsafeMax);\n  return { min: min, max: max };\n};\n\nvar minBounds = function minBounds(min) {\n  return boundsFrom(min, Infinity);\n};\n\nvar maxBounds = function maxBounds(max) {\n  return boundsFrom(0, max);\n};\n\n// Combine 2 bounds by narrowing min and max\nvar mergeBounds = function mergeBounds(b1, b2) {\n  return boundsFrom(b1.min + b2.min, Math.min(b1.max, b1.min + b2.max));\n};\n\n// Nil bounds excludes all slice indices\nvar isNilBounds = function isNilBounds(b) {\n  return b.min >= b.max;\n};\n\n// Infinite bounds includes all slice indices\nvar isInfiniteBounds = function isInfiniteBounds(b) {\n  return b.min <= 0 && b.max === Infinity;\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Filter = /*#__PURE__*/function () {\n  function Filter(p, source) {\n    classCallCheck(this, Filter);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  Filter.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new FilterSink(this.p, sink), scheduler$$1);\n  };\n\n  /**\n   * Create a filtered source, fusing adjacent filter.filter if possible\n   * @param {function(x:*):boolean} p filtering predicate\n   * @param {{run:function}} source source to filter\n   * @returns {Filter} filtered source\n   */\n\n\n  Filter.create = function create(p, source) {\n    if (isCanonicalEmpty(source)) {\n      return source;\n    }\n\n    if (source instanceof Filter) {\n      return new Filter(and(source.p, p), source.source);\n    }\n\n    return new Filter(p, source);\n  };\n\n  return Filter;\n}();\n\nvar FilterSink = /*#__PURE__*/function (_Pipe) {\n  inherits(FilterSink, _Pipe);\n\n  function FilterSink(p, sink) {\n    classCallCheck(this, FilterSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.p = p;\n    return _this;\n  }\n\n  FilterSink.prototype.event = function event(t, x) {\n    var p = this.p;\n    p(x) && this.sink.event(t, x);\n  };\n\n  return FilterSink;\n}(Pipe);\n\nvar and = function and(p, q) {\n  return function (x) {\n    return p(x) && q(x);\n  };\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar FilterMap = /*#__PURE__*/function () {\n  function FilterMap(p, f, source) {\n    classCallCheck(this, FilterMap);\n\n    this.p = p;\n    this.f = f;\n    this.source = source;\n  }\n\n  FilterMap.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler$$1);\n  };\n\n  return FilterMap;\n}();\n\nvar FilterMapSink = /*#__PURE__*/function (_Pipe) {\n  inherits(FilterMapSink, _Pipe);\n\n  function FilterMapSink(p, f, sink) {\n    classCallCheck(this, FilterMapSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.p = p;\n    _this.f = f;\n    return _this;\n  }\n\n  FilterMapSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    var p = this.p;\n    p(x) && this.sink.event(t, f(x));\n  };\n\n  return FilterMapSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Map = /*#__PURE__*/function () {\n  function Map(f, source) {\n    classCallCheck(this, Map);\n\n    this.f = f;\n    this.source = source;\n  }\n\n  Map.prototype.run = function run(sink, scheduler$$1) {\n    // eslint-disable-line no-extend-native\n    return this.source.run(new MapSink(this.f, sink), scheduler$$1);\n  };\n\n  /**\n   * Create a mapped source, fusing adjacent map.map, filter.map,\n   * and filter.map.map if possible\n   * @param {function(*):*} f mapping function\n   * @param {{run:function}} source source to map\n   * @returns {Map|FilterMap} mapped source, possibly fused\n   */\n\n\n  Map.create = function create(f, source) {\n    if (isCanonicalEmpty(source)) {\n      return empty();\n    }\n\n    if (source instanceof Map) {\n      return new Map(compose(f, source.f), source.source);\n    }\n\n    if (source instanceof Filter) {\n      return new FilterMap(source.p, f, source.source);\n    }\n\n    return new Map(f, source);\n  };\n\n  return Map;\n}();\n\nvar MapSink = /*#__PURE__*/function (_Pipe) {\n  inherits(MapSink, _Pipe);\n\n  function MapSink(f, sink) {\n    classCallCheck(this, MapSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    return _this;\n  }\n\n  MapSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    this.sink.event(t, f(x));\n  };\n\n  return MapSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar SettableDisposable = /*#__PURE__*/function () {\n  function SettableDisposable() {\n    classCallCheck(this, SettableDisposable);\n\n    this.disposable = undefined;\n    this.disposed = false;\n  }\n\n  SettableDisposable.prototype.setDisposable = function setDisposable(disposable$$1) {\n    if (this.disposable !== void 0) {\n      throw new Error('setDisposable called more than once');\n    }\n\n    this.disposable = disposable$$1;\n\n    if (this.disposed) {\n      disposable$$1.dispose();\n    }\n  };\n\n  SettableDisposable.prototype.dispose = function dispose() {\n    if (this.disposed) {\n      return;\n    }\n\n    this.disposed = true;\n\n    if (this.disposable !== void 0) {\n      this.disposable.dispose();\n    }\n  };\n\n  return SettableDisposable;\n}();\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream containing only up to the first n items from stream\n */\nvar take$1 = function take(n, stream) {\n  return sliceBounds(maxBounds(n), stream);\n};\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream with the first n items removed\n */\nvar skip$1 = function skip(n, stream) {\n  return sliceBounds(minBounds(n), stream);\n};\n\n/**\n * Slice a stream by index. Negative start/end indexes are not supported\n * @param {number} start\n * @param {number} end\n * @param {Stream} stream\n * @returns {Stream} stream containing items where start <= index < end\n */\nvar slice$1 = function slice(start, end, stream) {\n  return sliceBounds(boundsFrom(start, end), stream);\n};\n\nvar sliceBounds = function sliceBounds(bounds, stream) {\n  return isSliceEmpty(bounds, stream) ? empty() : stream instanceof Map ? commuteMapSlice(bounds, stream) : stream instanceof Slice ? fuseSlice(bounds, stream) : createSlice(bounds, stream);\n};\n\nvar isSliceEmpty = function isSliceEmpty(bounds, stream) {\n  return isCanonicalEmpty(stream) || isNilBounds(bounds);\n};\n\nvar createSlice = function createSlice(bounds, stream) {\n  return isInfiniteBounds(bounds) ? stream : new Slice(bounds, stream);\n};\n\nvar commuteMapSlice = function commuteMapSlice(bounds, mapStream) {\n  return Map.create(mapStream.f, sliceBounds(bounds, mapStream.source));\n};\n\nvar fuseSlice = function fuseSlice(bounds, sliceStream) {\n  return sliceBounds(mergeBounds(bounds, sliceStream.bounds), sliceStream.source);\n};\n\nvar Slice = /*#__PURE__*/function () {\n  function Slice(bounds, source) {\n    classCallCheck(this, Slice);\n\n    this.source = source;\n    this.bounds = bounds;\n  }\n\n  Slice.prototype.run = function run(sink, scheduler$$1) {\n    var disposable$$1 = new SettableDisposable();\n    var sliceSink = new SliceSink(this.bounds.min, this.bounds.max - this.bounds.min, sink, disposable$$1);\n\n    disposable$$1.setDisposable(this.source.run(sliceSink, scheduler$$1));\n\n    return disposable$$1;\n  };\n\n  return Slice;\n}();\n\nvar SliceSink = /*#__PURE__*/function (_Pipe) {\n  inherits(SliceSink, _Pipe);\n\n  function SliceSink(skip, take, sink, disposable$$1) {\n    classCallCheck(this, SliceSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.skip = skip;\n    _this.take = take;\n    _this.disposable = disposable$$1;\n    return _this;\n  }\n\n  SliceSink.prototype.event = function event(t, x) {\n    /* eslint complexity: [1, 4] */\n    if (this.skip > 0) {\n      this.skip -= 1;\n      return;\n    }\n\n    if (this.take === 0) {\n      return;\n    }\n\n    this.take -= 1;\n    this.sink.event(t, x);\n    if (this.take === 0) {\n      this.disposable.dispose();\n      this.sink.end(t);\n    }\n  };\n\n  return SliceSink;\n}(Pipe);\n\nvar takeWhile$1 = function takeWhile(p, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new TakeWhile(p, stream);\n};\n\nvar TakeWhile = /*#__PURE__*/function () {\n  function TakeWhile(p, source) {\n    classCallCheck(this, TakeWhile);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  TakeWhile.prototype.run = function run(sink, scheduler$$1) {\n    var disposable$$1 = new SettableDisposable();\n    var takeWhileSink = new TakeWhileSink(this.p, sink, disposable$$1);\n\n    disposable$$1.setDisposable(this.source.run(takeWhileSink, scheduler$$1));\n\n    return disposable$$1;\n  };\n\n  return TakeWhile;\n}();\n\nvar TakeWhileSink = /*#__PURE__*/function (_Pipe2) {\n  inherits(TakeWhileSink, _Pipe2);\n\n  function TakeWhileSink(p, sink, disposable$$1) {\n    classCallCheck(this, TakeWhileSink);\n\n    var _this2 = possibleConstructorReturn(this, _Pipe2.call(this, sink));\n\n    _this2.p = p;\n    _this2.active = true;\n    _this2.disposable = disposable$$1;\n    return _this2;\n  }\n\n  TakeWhileSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n\n    var p = this.p;\n    this.active = p(x);\n\n    if (this.active) {\n      this.sink.event(t, x);\n    } else {\n      this.disposable.dispose();\n      this.sink.end(t);\n    }\n  };\n\n  return TakeWhileSink;\n}(Pipe);\n\nvar skipWhile$1 = function skipWhile(p, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new SkipWhile(p, stream);\n};\n\nvar SkipWhile = /*#__PURE__*/function () {\n  function SkipWhile(p, source) {\n    classCallCheck(this, SkipWhile);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  SkipWhile.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new SkipWhileSink(this.p, sink), scheduler$$1);\n  };\n\n  return SkipWhile;\n}();\n\nvar SkipWhileSink = /*#__PURE__*/function (_Pipe3) {\n  inherits(SkipWhileSink, _Pipe3);\n\n  function SkipWhileSink(p, sink) {\n    classCallCheck(this, SkipWhileSink);\n\n    var _this3 = possibleConstructorReturn(this, _Pipe3.call(this, sink));\n\n    _this3.p = p;\n    _this3.skipping = true;\n    return _this3;\n  }\n\n  SkipWhileSink.prototype.event = function event(t, x) {\n    if (this.skipping) {\n      var p = this.p;\n      this.skipping = p(x);\n      if (this.skipping) {\n        return;\n      }\n    }\n\n    this.sink.event(t, x);\n  };\n\n  return SkipWhileSink;\n}(Pipe);\n\nvar skipAfter$1 = function skipAfter(p, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new SkipAfter(p, stream);\n};\n\nvar SkipAfter = /*#__PURE__*/function () {\n  function SkipAfter(p, source) {\n    classCallCheck(this, SkipAfter);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  SkipAfter.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new SkipAfterSink(this.p, sink), scheduler$$1);\n  };\n\n  return SkipAfter;\n}();\n\nvar SkipAfterSink = /*#__PURE__*/function (_Pipe4) {\n  inherits(SkipAfterSink, _Pipe4);\n\n  function SkipAfterSink(p, sink) {\n    classCallCheck(this, SkipAfterSink);\n\n    var _this4 = possibleConstructorReturn(this, _Pipe4.call(this, sink));\n\n    _this4.p = p;\n    _this4.skipping = false;\n    return _this4;\n  }\n\n  SkipAfterSink.prototype.event = function event(t, x) {\n    if (this.skipping) {\n      return;\n    }\n\n    var p = this.p;\n    this.skipping = p(x);\n    this.sink.event(t, x);\n\n    if (this.skipping) {\n      this.sink.end(t);\n    }\n  };\n\n  return SkipAfterSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2017 original author or authors */\n\nvar withItems$1 = function withItems(items, stream) {\n  return zipItems$1(keepLeft, items, stream);\n};\n\nvar zipItems$1 = function zipItems(f, items, stream) {\n  return isCanonicalEmpty(stream) || items.length === 0 ? empty() : new ZipItems(f, items, take$1(items.length, stream));\n};\n\nvar keepLeft = function keepLeft(a, _) {\n  return a;\n};\n\nvar ZipItems = /*#__PURE__*/function () {\n  function ZipItems(f, items, source) {\n    classCallCheck(this, ZipItems);\n\n    this.f = f;\n    this.items = items;\n    this.source = source;\n  }\n\n  ZipItems.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new ZipItemsSink(this.f, this.items, sink), scheduler$$1);\n  };\n\n  return ZipItems;\n}();\n\nvar ZipItemsSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ZipItemsSink, _Pipe);\n\n  function ZipItemsSink(f, items, sink) {\n    classCallCheck(this, ZipItemsSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.items = items;\n    _this.index = 0;\n    return _this;\n  }\n\n  ZipItemsSink.prototype.event = function event(t, b) {\n    var f = this.f;\n    this.sink.event(t, f(this.items[this.index], b));\n    this.index += 1;\n  };\n\n  return ZipItemsSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar runEffects$1 = /*#__PURE__*/curry2(function (stream, scheduler$$1) {\n  return new Promise(function (resolve, reject) {\n    return runStream(stream, scheduler$$1, resolve, reject);\n  });\n});\n\nfunction runStream(stream, scheduler$$1, resolve, reject) {\n  var disposable$$1 = new SettableDisposable();\n  var observer = new RunEffectsSink(resolve, reject, disposable$$1);\n\n  disposable$$1.setDisposable(stream.run(observer, scheduler$$1));\n}\n\nvar RunEffectsSink = /*#__PURE__*/function () {\n  function RunEffectsSink(end, error, disposable$$1) {\n    classCallCheck(this, RunEffectsSink);\n\n    this._end = end;\n    this._error = error;\n    this._disposable = disposable$$1;\n    this.active = true;\n  }\n\n  RunEffectsSink.prototype.event = function event(t, x) {};\n\n  RunEffectsSink.prototype.end = function end(t) {\n    if (!this.active) {\n      return;\n    }\n    this._dispose(this._error, this._end, undefined);\n  };\n\n  RunEffectsSink.prototype.error = function error(t, e) {\n    this._dispose(this._error, this._error, e);\n  };\n\n  RunEffectsSink.prototype._dispose = function _dispose(error, end, x) {\n    this.active = false;\n    tryDispose$1(error, end, x, this._disposable);\n  };\n\n  return RunEffectsSink;\n}();\n\nfunction tryDispose$1(error, end, x, disposable$$1) {\n  try {\n    disposable$$1.dispose();\n  } catch (e) {\n    error(e);\n    return;\n  }\n\n  end(x);\n}\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\n// Run a Stream, sending all its events to the\n// provided Sink.\nvar run$1 = function run(sink, scheduler$$1, stream) {\n    return stream.run(sink, scheduler$$1);\n};\n\nvar RelativeSink = /*#__PURE__*/function () {\n  function RelativeSink(offset, sink) {\n    classCallCheck(this, RelativeSink);\n\n    this.sink = sink;\n    this.offset = offset;\n  }\n\n  RelativeSink.prototype.event = function event(t, x) {\n    this.sink.event(t + this.offset, x);\n  };\n\n  RelativeSink.prototype.error = function error(t, e) {\n    this.sink.error(t + this.offset, e);\n  };\n\n  RelativeSink.prototype.end = function end(t) {\n    this.sink.end(t + this.offset);\n  };\n\n  return RelativeSink;\n}();\n\n// Create a stream with its own local clock\n// This transforms time from the provided scheduler's clock to a stream-local\n// clock (which starts at 0), and then *back* to the scheduler's clock before\n// propagating events to sink.  In other words, upstream sources will see local times,\n// and downstream sinks will see non-local (original) times.\nvar withLocalTime$1 = function withLocalTime(origin, stream) {\n  return new WithLocalTime(origin, stream);\n};\n\nvar WithLocalTime = /*#__PURE__*/function () {\n  function WithLocalTime(origin, source) {\n    classCallCheck(this, WithLocalTime);\n\n    this.origin = origin;\n    this.source = source;\n  }\n\n  WithLocalTime.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(relativeSink(this.origin, sink), schedulerRelativeTo(this.origin, scheduler$$1));\n  };\n\n  return WithLocalTime;\n}();\n\n// Accumulate offsets instead of nesting RelativeSinks, which can happen\n// with higher-order stream and combinators like continueWith when they're\n// applied recursively.\n\n\nvar relativeSink = function relativeSink(origin, sink) {\n  return sink instanceof RelativeSink ? new RelativeSink(origin + sink.offset, sink.sink) : new RelativeSink(origin, sink);\n};\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @param {Stream} stream event stream\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nvar loop$1 = function loop(stepper, seed, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Loop(stepper, seed, stream);\n};\n\nvar Loop = /*#__PURE__*/function () {\n  function Loop(stepper, seed, source) {\n    classCallCheck(this, Loop);\n\n    this.step = stepper;\n    this.seed = seed;\n    this.source = source;\n  }\n\n  Loop.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler$$1);\n  };\n\n  return Loop;\n}();\n\nvar LoopSink = /*#__PURE__*/function (_Pipe) {\n  inherits(LoopSink, _Pipe);\n\n  function LoopSink(stepper, seed, sink) {\n    classCallCheck(this, LoopSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.step = stepper;\n    _this.seed = seed;\n    return _this;\n  }\n\n  LoopSink.prototype.event = function event(t, x) {\n    var result = this.step(this.seed, x);\n    this.seed = result.seed;\n    this.sink.event(t, result.value);\n  };\n\n  return LoopSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @param {Stream} stream stream to scan\n * @returns {Stream} new stream containing successive reduce results\n */\nvar scan$1 = function scan(f, initial, stream) {\n  return new Scan(f, initial, stream);\n};\n\nvar Scan = /*#__PURE__*/function () {\n  function Scan(f, z, source) {\n    classCallCheck(this, Scan);\n\n    this.source = source;\n    this.f = f;\n    this.value = z;\n  }\n\n  Scan.prototype.run = function run(sink, scheduler$$1) {\n    var d1 = asap(propagateEventTask$1(this.value, sink), scheduler$$1);\n    var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler$$1);\n    return disposeBoth(d1, d2);\n  };\n\n  return Scan;\n}();\n\nvar ScanSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ScanSink, _Pipe);\n\n  function ScanSink(f, z, sink) {\n    classCallCheck(this, ScanSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.value = z;\n    return _this;\n  }\n\n  ScanSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    this.value = f(this.value, x);\n    this.sink.event(t, this.value);\n  };\n\n  return ScanSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar continueWith$1 = function continueWith(f, stream) {\n  return new ContinueWith(f, stream);\n};\n\nvar ContinueWith = /*#__PURE__*/function () {\n  function ContinueWith(f, source) {\n    classCallCheck(this, ContinueWith);\n\n    this.f = f;\n    this.source = source;\n  }\n\n  ContinueWith.prototype.run = function run(sink, scheduler$$1) {\n    return new ContinueWithSink(this.f, this.source, sink, scheduler$$1);\n  };\n\n  return ContinueWith;\n}();\n\nvar ContinueWithSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ContinueWithSink, _Pipe);\n\n  function ContinueWithSink(f, source, sink, scheduler$$1) {\n    classCallCheck(this, ContinueWithSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.scheduler = scheduler$$1;\n    _this.active = true;\n    _this.disposable = disposeOnce(source.run(_this, scheduler$$1));\n    return _this;\n  }\n\n  ContinueWithSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.sink.event(t, x);\n  };\n\n  ContinueWithSink.prototype.end = function end(t) {\n    if (!this.active) {\n      return;\n    }\n\n    tryDispose(t, this.disposable, this.sink);\n\n    this._startNext(t, this.sink);\n  };\n\n  ContinueWithSink.prototype._startNext = function _startNext(t, sink) {\n    try {\n      this.disposable = this._continue(this.f, t, sink);\n    } catch (e) {\n      sink.error(t, e);\n    }\n  };\n\n  ContinueWithSink.prototype._continue = function _continue(f, t, sink) {\n    return run$1(sink, this.scheduler, withLocalTime$1(t, f()));\n  };\n\n  ContinueWithSink.prototype.dispose = function dispose() {\n    this.active = false;\n    return this.disposable.dispose();\n  };\n\n  return ContinueWithSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar startWith$1 = function startWith(x, stream) {\n  return continueWith$1(function () {\n    return stream;\n  }, now(x));\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @param {Stream} stream stream to map\n * @returns {Stream} stream containing items transformed by f\n */\nvar map$2 = function map$$1(f, stream) {\n  return Map.create(f, stream);\n};\n\n/**\n* Replace each value in the stream with x\n* @param {*} x\n* @param {Stream} stream\n* @returns {Stream} stream containing items replaced with x\n*/\nvar constant$1 = function constant(x, stream) {\n  return map$2(function () {\n    return x;\n  }, stream);\n};\n\n/**\n* Perform a side effect for each item in the stream\n* @param {function(x:*):*} f side effect to execute for each item. The\n*  return value will be discarded.\n* @param {Stream} stream stream to tap\n* @returns {Stream} new stream containing the same items as this stream\n*/\nvar tap$1 = function tap(f, stream) {\n  return new Tap(f, stream);\n};\n\nvar Tap = /*#__PURE__*/function () {\n  function Tap(f, source) {\n    classCallCheck(this, Tap);\n\n    this.source = source;\n    this.f = f;\n  }\n\n  Tap.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new TapSink(this.f, sink), scheduler$$1);\n  };\n\n  return Tap;\n}();\n\nvar TapSink = /*#__PURE__*/function (_Pipe) {\n  inherits(TapSink, _Pipe);\n\n  function TapSink(f, sink) {\n    classCallCheck(this, TapSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    return _this;\n  }\n\n  TapSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    f(x);\n    this.sink.event(t, x);\n  };\n\n  return TapSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar IndexSink = /*#__PURE__*/function (_Sink) {\n  inherits(IndexSink, _Sink);\n\n  function IndexSink(i, sink) {\n    classCallCheck(this, IndexSink);\n\n    var _this = possibleConstructorReturn(this, _Sink.call(this, sink));\n\n    _this.index = i;\n    _this.active = true;\n    _this.value = undefined;\n    return _this;\n  }\n\n  IndexSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.value = x;\n    this.sink.event(t, this);\n  };\n\n  IndexSink.prototype.end = function end(t) {\n    if (!this.active) {\n      return;\n    }\n    this.active = false;\n    this.sink.event(t, this);\n  };\n\n  return IndexSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction invoke(f, args) {\n  /* eslint complexity: [2,7] */\n  switch (args.length) {\n    case 0:\n      return f();\n    case 1:\n      return f(args[0]);\n    case 2:\n      return f(args[0], args[1]);\n    case 3:\n      return f(args[0], args[1], args[2]);\n    case 4:\n      return f(args[0], args[1], args[2], args[3]);\n    case 5:\n      return f(args[0], args[1], args[2], args[3], args[4]);\n    default:\n      return f.apply(void 0, args);\n  }\n}\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Combine latest events from two streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nvar combine$1 = function combine(f, stream1, stream2) {\n  return combineArray$1(f, [stream1, stream2]);\n};\n\n/**\n* Combine latest events from all input streams\n* @param {function(...events):*} f function to combine most recent events\n* @param {[Stream]} streams most recent events\n* @returns {Stream} stream containing the result of applying f to the most recent\n*  event of each input stream, whenever a new event arrives on any stream.\n*/\nvar combineArray$1 = function combineArray(f, streams) {\n  return streams.length === 0 || containsCanonicalEmpty(streams) ? empty() : streams.length === 1 ? map$2(f, streams[0]) : new Combine(f, streams);\n};\n\nvar Combine = /*#__PURE__*/function () {\n  function Combine(f, sources) {\n    classCallCheck(this, Combine);\n\n    this.f = f;\n    this.sources = sources;\n  }\n\n  Combine.prototype.run = function run(sink, scheduler$$1) {\n    var l = this.sources.length;\n    var disposables = new Array(l);\n    var sinks = new Array(l);\n\n    var mergeSink = new CombineSink(disposables, sinks, sink, this.f);\n\n    for (var indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink);\n      disposables[i] = this.sources[i].run(indexSink, scheduler$$1);\n    }\n\n    return disposeAll(disposables);\n  };\n\n  return Combine;\n}();\n\nvar CombineSink = /*#__PURE__*/function (_Pipe) {\n  inherits(CombineSink, _Pipe);\n\n  function CombineSink(disposables, sinks, sink, f) {\n    classCallCheck(this, CombineSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.disposables = disposables;\n    _this.sinks = sinks;\n    _this.f = f;\n\n    var l = sinks.length;\n    _this.awaiting = l;\n    _this.values = new Array(l);\n    _this.hasValue = new Array(l).fill(false);\n    _this.activeCount = sinks.length;\n    return _this;\n  }\n\n  CombineSink.prototype.event = function event(t, indexedValue) {\n    if (!indexedValue.active) {\n      this._dispose(t, indexedValue.index);\n      return;\n    }\n\n    var i = indexedValue.index;\n    var awaiting = this._updateReady(i);\n\n    this.values[i] = indexedValue.value;\n    if (awaiting === 0) {\n      this.sink.event(t, invoke(this.f, this.values));\n    }\n  };\n\n  CombineSink.prototype._updateReady = function _updateReady(index) {\n    if (this.awaiting > 0) {\n      if (!this.hasValue[index]) {\n        this.hasValue[index] = true;\n        this.awaiting -= 1;\n      }\n    }\n    return this.awaiting;\n  };\n\n  CombineSink.prototype._dispose = function _dispose(t, index) {\n    tryDispose(t, this.disposables[index], this.sink);\n    if (--this.activeCount === 0) {\n      this.sink.end(t);\n    }\n  };\n\n  return CombineSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Assume fs is a stream containing functions, and apply the latest function\n * in fs to the latest value in xs.\n * fs:         --f---------g--------h------>\n * xs:         -a-------b-------c-------d-->\n * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->\n * @param {Stream} fs stream of functions to apply to the latest x\n * @param {Stream} xs stream of values to which to apply all the latest f\n * @returns {Stream} stream containing all the applications of fs to xs\n */\nfunction ap$1(fs, xs) {\n  return combine$1(apply, fs, xs);\n}\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Doubly linked list\n * @constructor\n */\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    classCallCheck(this, LinkedList);\n\n    this.head = null;\n    this.length = 0;\n  }\n\n  /**\n   * Add a node to the end of the list\n   * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to add\n   */\n\n\n  LinkedList.prototype.add = function add(x) {\n    if (this.head !== null) {\n      this.head.prev = x;\n      x.next = this.head;\n    }\n    this.head = x;\n    ++this.length;\n  };\n\n  /**\n   * Remove the provided node from the list\n   * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to remove\n   */\n\n\n  LinkedList.prototype.remove = function remove$$1(x) {\n    // eslint-disable-line  complexity\n    --this.length;\n    if (x === this.head) {\n      this.head = this.head.next;\n    }\n    if (x.next !== null) {\n      x.next.prev = x.prev;\n      x.next = null;\n    }\n    if (x.prev !== null) {\n      x.prev.next = x.next;\n      x.prev = null;\n    }\n  };\n\n  /**\n   * @returns {boolean} true iff there are no nodes in the list\n   */\n\n\n  LinkedList.prototype.isEmpty = function isEmpty() {\n    return this.length === 0;\n  };\n\n  /**\n   * Dispose all nodes\n   * @returns {void}\n   */\n\n\n  LinkedList.prototype.dispose = function dispose() {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    var head = this.head;\n    this.head = null;\n    this.length = 0;\n\n    while (head !== null) {\n      head.dispose();\n      head = head.next;\n    }\n  };\n\n  return LinkedList;\n}();\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\nvar mergeConcurrently$1 = function mergeConcurrently(concurrency, stream) {\n  return mergeMapConcurrently$1(id, concurrency, stream);\n};\n\nvar mergeMapConcurrently$1 = function mergeMapConcurrently(f, concurrency, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new MergeConcurrently(f, concurrency, stream);\n};\n\nvar MergeConcurrently = /*#__PURE__*/function () {\n  function MergeConcurrently(f, concurrency, source) {\n    classCallCheck(this, MergeConcurrently);\n\n    this.f = f;\n    this.concurrency = concurrency;\n    this.source = source;\n  }\n\n  MergeConcurrently.prototype.run = function run(sink, scheduler$$1) {\n    return new Outer(this.f, this.concurrency, this.source, sink, scheduler$$1);\n  };\n\n  return MergeConcurrently;\n}();\n\nvar Outer = /*#__PURE__*/function () {\n  function Outer(f, concurrency, source, sink, scheduler$$1) {\n    classCallCheck(this, Outer);\n\n    this.f = f;\n    this.concurrency = concurrency;\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.pending = [];\n    this.current = new LinkedList();\n    this.disposable = disposeOnce(source.run(this, scheduler$$1));\n    this.active = true;\n  }\n\n  Outer.prototype.event = function event(t, x) {\n    this._addInner(t, x);\n  };\n\n  Outer.prototype._addInner = function _addInner(t, x) {\n    if (this.current.length < this.concurrency) {\n      this._startInner(t, x);\n    } else {\n      this.pending.push(x);\n    }\n  };\n\n  Outer.prototype._startInner = function _startInner(t, x) {\n    try {\n      this._initInner(t, x);\n    } catch (e) {\n      this.error(t, e);\n    }\n  };\n\n  Outer.prototype._initInner = function _initInner(t, x) {\n    var innerSink = new Inner(t, this, this.sink);\n    innerSink.disposable = mapAndRun(this.f, t, x, innerSink, this.scheduler);\n    this.current.add(innerSink);\n  };\n\n  Outer.prototype.end = function end(t) {\n    this.active = false;\n    tryDispose(t, this.disposable, this.sink);\n    this._checkEnd(t);\n  };\n\n  Outer.prototype.error = function error(t, e) {\n    this.active = false;\n    this.sink.error(t, e);\n  };\n\n  Outer.prototype.dispose = function dispose() {\n    this.active = false;\n    this.pending.length = 0;\n    this.disposable.dispose();\n    this.current.dispose();\n  };\n\n  Outer.prototype._endInner = function _endInner(t, inner) {\n    this.current.remove(inner);\n    tryDispose(t, inner, this);\n\n    if (this.pending.length === 0) {\n      this._checkEnd(t);\n    } else {\n      this._startInner(t, this.pending.shift());\n    }\n  };\n\n  Outer.prototype._checkEnd = function _checkEnd(t) {\n    if (!this.active && this.current.isEmpty()) {\n      this.sink.end(t);\n    }\n  };\n\n  return Outer;\n}();\n\nvar mapAndRun = function mapAndRun(f, t, x, sink, scheduler$$1) {\n  return f(x).run(sink, schedulerRelativeTo(t, scheduler$$1));\n};\n\nvar Inner = /*#__PURE__*/function () {\n  function Inner(time, outer, sink) {\n    classCallCheck(this, Inner);\n\n    this.prev = this.next = null;\n    this.time = time;\n    this.outer = outer;\n    this.sink = sink;\n    this.disposable = void 0;\n  }\n\n  Inner.prototype.event = function event(t, x) {\n    this.sink.event(t + this.time, x);\n  };\n\n  Inner.prototype.end = function end(t) {\n    this.outer._endInner(t + this.time, this);\n  };\n\n  Inner.prototype.error = function error(t, e) {\n    this.outer.error(t + this.time, e);\n  };\n\n  Inner.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return Inner;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nvar chain$1 = function chain(f, stream) {\n  return mergeMapConcurrently$1(f, Infinity, stream);\n};\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @param {Stream<Stream<X>>} stream stream of streams\n * @returns {Stream<X>} new stream containing all events of all inner streams\n */\nvar join = function join(stream) {\n  return mergeConcurrently$1(Infinity, stream);\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Map each value in stream to a new stream, and concatenate them all\n * stream:              -a---b---cX\n * f(a):                 1-1-1-1X\n * f(b):                        -2-2-2-2X\n * f(c):                                -3-3-3-3X\n * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X\n * @param {function(x:*):Stream} f function to map each value to a stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nvar concatMap$1 = function concatMap(f, stream) {\n  return mergeMapConcurrently$1(f, 1, stream);\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * @returns {Stream} stream containing events from two streams in time order.\n * If two events are simultaneous they will be merged in arbitrary order.\n */\nfunction merge$1(stream1, stream2) {\n  return mergeArray([stream1, stream2]);\n}\n\n/**\n * @param {Array} streams array of stream to merge\n * @returns {Stream} stream containing events from all input observables\n * in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nvar mergeArray = function mergeArray(streams) {\n  return mergeStreams(withoutCanonicalEmpty(streams));\n};\n\n/**\n * This implements fusion/flattening for merge.  It will\n * fuse adjacent merge operations.  For example:\n * - a.merge(b).merge(c) effectively becomes merge(a, b, c)\n * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)\n * It does this by concatenating the sources arrays of\n * any nested Merge sources, in effect \"flattening\" nested\n * merge operations into a single merge.\n */\nvar mergeStreams = function mergeStreams(streams) {\n  return streams.length === 0 ? empty() : streams.length === 1 ? streams[0] : new Merge(reduce(appendSources, [], streams));\n};\n\nvar withoutCanonicalEmpty = function withoutCanonicalEmpty(streams) {\n  return streams.filter(isNotCanonicalEmpty);\n};\n\nvar isNotCanonicalEmpty = function isNotCanonicalEmpty(stream) {\n  return !isCanonicalEmpty(stream);\n};\n\nvar appendSources = function appendSources(sources, stream) {\n  return sources.concat(stream instanceof Merge ? stream.sources : stream);\n};\n\nvar Merge = /*#__PURE__*/function () {\n  function Merge(sources) {\n    classCallCheck(this, Merge);\n\n    this.sources = sources;\n  }\n\n  Merge.prototype.run = function run(sink, scheduler$$1) {\n    var l = this.sources.length;\n    var disposables = new Array(l);\n    var sinks = new Array(l);\n\n    var mergeSink = new MergeSink(disposables, sinks, sink);\n\n    for (var indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink);\n      disposables[i] = this.sources[i].run(indexSink, scheduler$$1);\n    }\n\n    return disposeAll(disposables);\n  };\n\n  return Merge;\n}();\n\nvar MergeSink = /*#__PURE__*/function (_Pipe) {\n  inherits(MergeSink, _Pipe);\n\n  function MergeSink(disposables, sinks, sink) {\n    classCallCheck(this, MergeSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.disposables = disposables;\n    _this.activeCount = sinks.length;\n    return _this;\n  }\n\n  MergeSink.prototype.event = function event(t, indexValue) {\n    if (!indexValue.active) {\n      this._dispose(t, indexValue.index);\n      return;\n    }\n    this.sink.event(t, indexValue.value);\n  };\n\n  MergeSink.prototype._dispose = function _dispose(t, index) {\n    tryDispose(t, this.disposables[index], this.sink);\n    if (--this.activeCount === 0) {\n      this.sink.end(t);\n    }\n  };\n\n  return MergeSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\nvar sample$1 = function sample(values, sampler) {\n  return snapshot$1(function (x, _) {\n    return x;\n  }, values, sampler);\n};\n\nvar snapshot$1 = function snapshot(f, values, sampler) {\n  return isCanonicalEmpty(sampler) || isCanonicalEmpty(values) ? empty() : new Snapshot(f, values, sampler);\n};\n\nvar Snapshot = /*#__PURE__*/function () {\n  function Snapshot(f, values, sampler) {\n    classCallCheck(this, Snapshot);\n\n    this.f = f;\n    this.values = values;\n    this.sampler = sampler;\n  }\n\n  Snapshot.prototype.run = function run(sink, scheduler$$1) {\n    var sampleSink = new SnapshotSink(this.f, sink);\n    var valuesDisposable = this.values.run(sampleSink.latest, scheduler$$1);\n    var samplerDisposable = this.sampler.run(sampleSink, scheduler$$1);\n\n    return disposeBoth(samplerDisposable, valuesDisposable);\n  };\n\n  return Snapshot;\n}();\n\nvar SnapshotSink = /*#__PURE__*/function (_Pipe) {\n  inherits(SnapshotSink, _Pipe);\n\n  function SnapshotSink(f, sink) {\n    classCallCheck(this, SnapshotSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.latest = new LatestValueSink(_this);\n    return _this;\n  }\n\n  SnapshotSink.prototype.event = function event(t, x) {\n    if (this.latest.hasValue) {\n      var f = this.f;\n      this.sink.event(t, f(this.latest.value, x));\n    }\n  };\n\n  return SnapshotSink;\n}(Pipe);\n\nvar LatestValueSink = /*#__PURE__*/function (_Pipe2) {\n  inherits(LatestValueSink, _Pipe2);\n\n  function LatestValueSink(sink) {\n    classCallCheck(this, LatestValueSink);\n\n    var _this2 = possibleConstructorReturn(this, _Pipe2.call(this, sink));\n\n    _this2.hasValue = false;\n    return _this2;\n  }\n\n  LatestValueSink.prototype.event = function event(t, x) {\n    this.value = x;\n    this.hasValue = true;\n  };\n\n  LatestValueSink.prototype.end = function end() {};\n\n  return LatestValueSink;\n}(Pipe);\n\n// Copied and modified from https://github.com/invertase/denque\n// MIT License\n\n// These constants were extracted directly from denque's shift()\n// It's not clear exactly why the authors chose these particular\n// values, but given denque's stated goals, it seems likely that\n// they were chosen for speed/memory reasons.\n\n// Max value of _head at which Queue is willing to shink\n// its internal array\nvar HEAD_MAX_SHRINK = 2;\n\n// Min value of _tail at which Queue is willing to shink\n// its internal array\nvar TAIL_MIN_SHRINK = 10000;\n\nvar Queue = /*#__PURE__*/function () {\n  function Queue() {\n    classCallCheck(this, Queue);\n\n    this._head = 0;\n    this._tail = 0;\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n\n  Queue.prototype.push = function push(x) {\n    var tail = this._tail;\n    this._list[tail] = x;\n    this._tail = tail + 1 & this._capacityMask;\n    if (this._tail === this._head) {\n      this._growArray();\n    }\n\n    if (this._head < this._tail) {\n      return this._tail - this._head;\n    } else {\n      return this._capacityMask + 1 - (this._head - this._tail);\n    }\n  };\n\n  Queue.prototype.shift = function shift() {\n    var head = this._head;\n    if (head === this._tail) {\n      return undefined;\n    }\n\n    var x = this._list[head];\n    this._list[head] = undefined;\n    this._head = head + 1 & this._capacityMask;\n    if (head < HEAD_MAX_SHRINK && this._tail > TAIL_MIN_SHRINK && this._tail <= this._list.length >>> 2) {\n      this._shrinkArray();\n    }\n\n    return x;\n  };\n\n  Queue.prototype.isEmpty = function isEmpty() {\n    return this._head === this._tail;\n  };\n\n  Queue.prototype.length = function length() {\n    if (this._head === this._tail) {\n      return 0;\n    } else if (this._head < this._tail) {\n      return this._tail - this._head;\n    } else {\n      return this._capacityMask + 1 - (this._head - this._tail);\n    }\n  };\n\n  Queue.prototype._growArray = function _growArray() {\n    if (this._head) {\n      // copy existing data, head to end, then beginning to tail.\n      this._list = this._copyArray();\n      this._head = 0;\n    }\n\n    // head is at 0 and array is now full, safe to extend\n    this._tail = this._list.length;\n\n    this._list.length *= 2;\n    this._capacityMask = this._capacityMask << 1 | 1;\n  };\n\n  Queue.prototype._shrinkArray = function _shrinkArray() {\n    this._list.length >>>= 1;\n    this._capacityMask >>>= 1;\n  };\n\n  Queue.prototype._copyArray = function _copyArray() {\n    var newArray = [];\n    var list = this._list;\n    var len = list.length;\n\n    var i = void 0;\n    for (i = this._head; i < len; i++) {\n      newArray.push(list[i]);\n    }\n    for (i = 0; i < this._tail; i++) {\n      newArray.push(list[i]);\n    }\n\n    return newArray;\n  };\n\n  return Queue;\n}();\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Combine two streams pairwise by index by applying f to values at corresponding\n * indices.  The returned stream ends when either of the input streams ends.\n * @param {function} f function to combine values\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nfunction zip$1(f, stream1, stream2) {\n  return zipArray$1(f, [stream1, stream2]);\n}\n\n/**\n* Combine streams pairwise (or tuple-wise) by index by applying f to values\n* at corresponding indices.  The returned stream ends when any of the input\n* streams ends.\n* @param {function} f function to combine values\n* @param {[Stream]} streams streams to zip using f\n* @returns {Stream} new stream with items at corresponding indices combined\n*  using f\n*/\nvar zipArray$1 = function zipArray(f, streams) {\n  return streams.length === 0 || containsCanonicalEmpty(streams) ? empty() : streams.length === 1 ? map$2(f, streams[0]) : new Zip(f, streams);\n};\n\nvar Zip = /*#__PURE__*/function () {\n  function Zip(f, sources) {\n    classCallCheck(this, Zip);\n\n    this.f = f;\n    this.sources = sources;\n  }\n\n  Zip.prototype.run = function run(sink, scheduler$$1) {\n    var l = this.sources.length;\n    var disposables = new Array(l);\n    var sinks = new Array(l);\n    var buffers = new Array(l);\n\n    var zipSink = new ZipSink(this.f, buffers, sinks, sink);\n\n    for (var indexSink, i = 0; i < l; ++i) {\n      buffers[i] = new Queue();\n      indexSink = sinks[i] = new IndexSink(i, zipSink);\n      disposables[i] = this.sources[i].run(indexSink, scheduler$$1);\n    }\n\n    return disposeAll(disposables);\n  };\n\n  return Zip;\n}();\n\nvar ZipSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ZipSink, _Pipe);\n\n  function ZipSink(f, buffers, sinks, sink) {\n    classCallCheck(this, ZipSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.sinks = sinks;\n    _this.buffers = buffers;\n    return _this;\n  }\n\n  ZipSink.prototype.event = function event(t, indexedValue) {\n    /* eslint complexity: [1, 5] */\n    if (!indexedValue.active) {\n      this._dispose(t, indexedValue.index);\n      return;\n    }\n\n    var buffers = this.buffers;\n    var buffer = buffers[indexedValue.index];\n\n    buffer.push(indexedValue.value);\n\n    if (buffer.length() === 1) {\n      if (!ready(this.buffers)) {\n        return;\n      }\n\n      emitZipped(this.f, t, buffers, this.sink);\n\n      if (ended(this.buffers, this.sinks)) {\n        this.sink.end(t);\n      }\n    }\n  };\n\n  ZipSink.prototype._dispose = function _dispose(t, index) {\n    var buffer = this.buffers[index];\n    if (buffer.isEmpty()) {\n      this.sink.end(t);\n    }\n  };\n\n  return ZipSink;\n}(Pipe);\n\nvar emitZipped = function emitZipped(f, t, buffers, sink) {\n  return sink.event(t, invoke(f, map(head, buffers)));\n};\n\nvar head = function head(buffer) {\n  return buffer.shift();\n};\n\nfunction ended(buffers, sinks) {\n  for (var i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty() && !sinks[i].active) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction ready(buffers) {\n  for (var i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty()) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @param {Stream} stream of streams on which to switch\n * @returns {Stream} switching stream\n */\nvar switchLatest = function switchLatest(stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Switch(stream);\n};\n\nvar Switch = /*#__PURE__*/function () {\n  function Switch(source) {\n    classCallCheck(this, Switch);\n\n    this.source = source;\n  }\n\n  Switch.prototype.run = function run(sink, scheduler$$1) {\n    var switchSink = new SwitchSink(sink, scheduler$$1);\n    return disposeBoth(switchSink, this.source.run(switchSink, scheduler$$1));\n  };\n\n  return Switch;\n}();\n\nvar SwitchSink = /*#__PURE__*/function () {\n  function SwitchSink(sink, scheduler$$1) {\n    classCallCheck(this, SwitchSink);\n\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.current = null;\n    this.ended = false;\n  }\n\n  SwitchSink.prototype.event = function event(t, stream) {\n    this._disposeCurrent(t);\n    this.current = new Segment(stream, t, Infinity, this, this.sink, this.scheduler);\n  };\n\n  SwitchSink.prototype.end = function end(t) {\n    this.ended = true;\n    this._checkEnd(t);\n  };\n\n  SwitchSink.prototype.error = function error(t, e) {\n    this.ended = true;\n    this.sink.error(t, e);\n  };\n\n  SwitchSink.prototype.dispose = function dispose() {\n    return this._disposeCurrent(currentTime(this.scheduler));\n  };\n\n  SwitchSink.prototype._disposeCurrent = function _disposeCurrent(t) {\n    if (this.current !== null) {\n      return this.current._dispose(t);\n    }\n  };\n\n  SwitchSink.prototype._disposeInner = function _disposeInner(t, inner) {\n    inner._dispose(t);\n    if (inner === this.current) {\n      this.current = null;\n    }\n  };\n\n  SwitchSink.prototype._checkEnd = function _checkEnd(t) {\n    if (this.ended && this.current === null) {\n      this.sink.end(t);\n    }\n  };\n\n  SwitchSink.prototype._endInner = function _endInner(t, inner) {\n    this._disposeInner(t, inner);\n    this._checkEnd(t);\n  };\n\n  SwitchSink.prototype._errorInner = function _errorInner(t, e, inner) {\n    this._disposeInner(t, inner);\n    this.sink.error(t, e);\n  };\n\n  return SwitchSink;\n}();\n\nvar Segment = /*#__PURE__*/function () {\n  function Segment(source, min, max, outer, sink, scheduler$$1) {\n    classCallCheck(this, Segment);\n\n    this.min = min;\n    this.max = max;\n    this.outer = outer;\n    this.sink = sink;\n    this.disposable = source.run(this, schedulerRelativeTo(min, scheduler$$1));\n  }\n\n  Segment.prototype.event = function event(t, x) {\n    var time = Math.max(0, t + this.min);\n    if (time < this.max) {\n      this.sink.event(time, x);\n    }\n  };\n\n  Segment.prototype.end = function end(t) {\n    this.outer._endInner(t + this.min, this);\n  };\n\n  Segment.prototype.error = function error(t, e) {\n    this.outer._errorInner(t + this.min, e, this);\n  };\n\n  Segment.prototype._dispose = function _dispose(t) {\n    tryDispose(t + this.min, this.disposable, this.sink);\n  };\n\n  return Segment;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Retain only items matching a predicate\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @param {Stream} stream stream to filter\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\nvar filter$1 = function filter(p, stream) {\n  return Filter.create(p, stream);\n};\n\n/**\n * Skip repeated events, using === to detect duplicates\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nvar skipRepeats = function skipRepeats(stream) {\n  return skipRepeatsWith$1(same, stream);\n};\n\n/**\n * Skip repeated events using the provided equals function to detect duplicates\n * @param {function(a:*, b:*):boolean} equals optional function to compare items\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nvar skipRepeatsWith$1 = function skipRepeatsWith(equals, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new SkipRepeats(equals, stream);\n};\n\nvar SkipRepeats = /*#__PURE__*/function () {\n  function SkipRepeats(equals, source) {\n    classCallCheck(this, SkipRepeats);\n\n    this.equals = equals;\n    this.source = source;\n  }\n\n  SkipRepeats.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler$$1);\n  };\n\n  return SkipRepeats;\n}();\n\nvar SkipRepeatsSink = /*#__PURE__*/function (_Pipe) {\n  inherits(SkipRepeatsSink, _Pipe);\n\n  function SkipRepeatsSink(equals, sink) {\n    classCallCheck(this, SkipRepeatsSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.equals = equals;\n    _this.value = void 0;\n    _this.init = true;\n    return _this;\n  }\n\n  SkipRepeatsSink.prototype.event = function event(t, x) {\n    if (this.init) {\n      this.init = false;\n      this.value = x;\n      this.sink.event(t, x);\n    } else if (!this.equals(this.value, x)) {\n      this.value = x;\n      this.sink.event(t, x);\n    }\n  };\n\n  return SkipRepeatsSink;\n}(Pipe);\n\nfunction same(a, b) {\n  return a === b;\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar until$1 = function until(signal, stream) {\n  return new Until(signal, stream);\n};\n\nvar since$1 = function since(signal, stream) {\n  return new Since(signal, stream);\n};\n\nvar during$1 = function during(timeWindow, stream) {\n  return until$1(join(timeWindow), since$1(timeWindow, stream));\n};\n\nvar Until = /*#__PURE__*/function () {\n  function Until(maxSignal, source) {\n    classCallCheck(this, Until);\n\n    this.maxSignal = maxSignal;\n    this.source = source;\n  }\n\n  Until.prototype.run = function run(sink, scheduler$$1) {\n    var min = new Bound(-Infinity, sink);\n    var max = new UpperBound(this.maxSignal, sink, scheduler$$1);\n    var disposable$$1 = this.source.run(new TimeWindowSink(min, max, sink), scheduler$$1);\n\n    return disposeAll([min, max, disposable$$1]);\n  };\n\n  return Until;\n}();\n\nvar Since = /*#__PURE__*/function () {\n  function Since(minSignal, source) {\n    classCallCheck(this, Since);\n\n    this.minSignal = minSignal;\n    this.source = source;\n  }\n\n  Since.prototype.run = function run(sink, scheduler$$1) {\n    var min = new LowerBound(this.minSignal, sink, scheduler$$1);\n    var max = new Bound(Infinity, sink);\n    var disposable$$1 = this.source.run(new TimeWindowSink(min, max, sink), scheduler$$1);\n\n    return disposeAll([min, max, disposable$$1]);\n  };\n\n  return Since;\n}();\n\nvar Bound = /*#__PURE__*/function (_Pipe) {\n  inherits(Bound, _Pipe);\n\n  function Bound(value, sink) {\n    classCallCheck(this, Bound);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.value = value;\n    return _this;\n  }\n\n  Bound.prototype.event = function event() {};\n\n  Bound.prototype.end = function end() {};\n\n  Bound.prototype.dispose = function dispose() {};\n\n  return Bound;\n}(Pipe);\n\nvar TimeWindowSink = /*#__PURE__*/function (_Pipe2) {\n  inherits(TimeWindowSink, _Pipe2);\n\n  function TimeWindowSink(min, max, sink) {\n    classCallCheck(this, TimeWindowSink);\n\n    var _this2 = possibleConstructorReturn(this, _Pipe2.call(this, sink));\n\n    _this2.min = min;\n    _this2.max = max;\n    return _this2;\n  }\n\n  TimeWindowSink.prototype.event = function event(t, x) {\n    if (t >= this.min.value && t < this.max.value) {\n      this.sink.event(t, x);\n    }\n  };\n\n  return TimeWindowSink;\n}(Pipe);\n\nvar LowerBound = /*#__PURE__*/function (_Pipe3) {\n  inherits(LowerBound, _Pipe3);\n\n  function LowerBound(signal, sink, scheduler$$1) {\n    classCallCheck(this, LowerBound);\n\n    var _this3 = possibleConstructorReturn(this, _Pipe3.call(this, sink));\n\n    _this3.value = Infinity;\n    _this3.disposable = signal.run(_this3, scheduler$$1);\n    return _this3;\n  }\n\n  LowerBound.prototype.event = function event(t /*, x */) {\n    if (t < this.value) {\n      this.value = t;\n    }\n  };\n\n  LowerBound.prototype.end = function end() {};\n\n  LowerBound.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return LowerBound;\n}(Pipe);\n\nvar UpperBound = /*#__PURE__*/function (_Pipe4) {\n  inherits(UpperBound, _Pipe4);\n\n  function UpperBound(signal, sink, scheduler$$1) {\n    classCallCheck(this, UpperBound);\n\n    var _this4 = possibleConstructorReturn(this, _Pipe4.call(this, sink));\n\n    _this4.value = Infinity;\n    _this4.disposable = signal.run(_this4, scheduler$$1);\n    return _this4;\n  }\n\n  UpperBound.prototype.event = function event(t, x) {\n    if (t < this.value) {\n      this.value = t;\n      this.sink.end(t);\n    }\n  };\n\n  UpperBound.prototype.end = function end() {};\n\n  UpperBound.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return UpperBound;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @param {Stream} stream\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\nvar delay$2 = function delay$$1(delayTime, stream) {\n  return delayTime <= 0 ? stream : new Delay(delayTime, stream);\n};\n\nvar Delay = /*#__PURE__*/function () {\n  function Delay(dt, source) {\n    classCallCheck(this, Delay);\n\n    this.dt = dt;\n    this.source = source;\n  }\n\n  Delay.prototype.run = function run(sink, scheduler$$1) {\n    var delaySink = new DelaySink(this.dt, sink, scheduler$$1);\n    return disposeBoth(delaySink, this.source.run(delaySink, scheduler$$1));\n  };\n\n  return Delay;\n}();\n\nvar DelaySink = /*#__PURE__*/function (_Pipe) {\n  inherits(DelaySink, _Pipe);\n\n  function DelaySink(dt, sink, scheduler$$1) {\n    classCallCheck(this, DelaySink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.dt = dt;\n    _this.scheduler = scheduler$$1;\n    return _this;\n  }\n\n  DelaySink.prototype.dispose = function dispose() {\n    var _this2 = this;\n\n    cancelAllTasks(function (task) {\n      return task.sink === _this2.sink;\n    }, this.scheduler);\n  };\n\n  DelaySink.prototype.event = function event(t, x) {\n    delay(this.dt, propagateEventTask$1(x, this.sink), this.scheduler);\n  };\n\n  DelaySink.prototype.end = function end(t) {\n    delay(this.dt, propagateEndTask(this.sink), this.scheduler);\n  };\n\n  return DelaySink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\n/**\n * Limit the rate of events by suppressing events that occur too often\n * @param {Number} period time to suppress events\n * @param {Stream} stream\n * @returns {Stream}\n */\nvar throttle$1 = function throttle(period, stream) {\n  return isCanonicalEmpty(stream) ? empty() : stream instanceof Map ? commuteMapThrottle(period, stream) : stream instanceof Throttle ? fuseThrottle(period, stream) : new Throttle(period, stream);\n};\n\nvar commuteMapThrottle = function commuteMapThrottle(period, mapStream) {\n  return Map.create(mapStream.f, throttle$1(period, mapStream.source));\n};\n\nvar fuseThrottle = function fuseThrottle(period, throttleStream) {\n  return new Throttle(Math.max(period, throttleStream.period), throttleStream.source);\n};\n\nvar Throttle = /*#__PURE__*/function () {\n  function Throttle(period, source) {\n    classCallCheck(this, Throttle);\n\n    this.period = period;\n    this.source = source;\n  }\n\n  Throttle.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new ThrottleSink(this.period, sink), scheduler$$1);\n  };\n\n  return Throttle;\n}();\n\nvar ThrottleSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ThrottleSink, _Pipe);\n\n  function ThrottleSink(period, sink) {\n    classCallCheck(this, ThrottleSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.time = 0;\n    _this.period = period;\n    return _this;\n  }\n\n  ThrottleSink.prototype.event = function event(t, x) {\n    if (t >= this.time) {\n      this.time = t + this.period;\n      this.sink.event(t, x);\n    }\n  };\n\n  return ThrottleSink;\n}(Pipe);\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * @param {Number} period events occuring more frequently than this\n *  will be suppressed\n * @param {Stream} stream stream to debounce\n * @returns {Stream} new debounced stream\n */\n\n\nvar debounce$1 = function debounce(period, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Debounce(period, stream);\n};\n\nvar Debounce = /*#__PURE__*/function () {\n  function Debounce(dt, source) {\n    classCallCheck(this, Debounce);\n\n    this.dt = dt;\n    this.source = source;\n  }\n\n  Debounce.prototype.run = function run(sink, scheduler$$1) {\n    return new DebounceSink(this.dt, this.source, sink, scheduler$$1);\n  };\n\n  return Debounce;\n}();\n\nvar DebounceSink = /*#__PURE__*/function () {\n  function DebounceSink(dt, source, sink, scheduler$$1) {\n    classCallCheck(this, DebounceSink);\n\n    this.dt = dt;\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.value = void 0;\n    this.timer = null;\n\n    this.disposable = source.run(this, scheduler$$1);\n  }\n\n  DebounceSink.prototype.event = function event(t, x) {\n    this._clearTimer();\n    this.value = x;\n    this.timer = delay(this.dt, new DebounceTask(this, x), this.scheduler);\n  };\n\n  DebounceSink.prototype._event = function _event(t, x) {\n    this._clearTimer();\n    this.sink.event(t, x);\n  };\n\n  DebounceSink.prototype.end = function end(t) {\n    if (this._clearTimer()) {\n      this.sink.event(t, this.value);\n      this.value = undefined;\n    }\n    this.sink.end(t);\n  };\n\n  DebounceSink.prototype.error = function error(t, x) {\n    this._clearTimer();\n    this.sink.error(t, x);\n  };\n\n  DebounceSink.prototype.dispose = function dispose() {\n    this._clearTimer();\n    this.disposable.dispose();\n  };\n\n  DebounceSink.prototype._clearTimer = function _clearTimer() {\n    if (this.timer === null) {\n      return false;\n    }\n    this.timer.dispose();\n    this.timer = null;\n    return true;\n  };\n\n  return DebounceSink;\n}();\n\nvar DebounceTask = /*#__PURE__*/function () {\n  function DebounceTask(debounce, value) {\n    classCallCheck(this, DebounceTask);\n\n    this.debounce = debounce;\n    this.value = value;\n  }\n\n  DebounceTask.prototype.run = function run(t) {\n    this.debounce._event(t, this.value);\n  };\n\n  DebounceTask.prototype.error = function error(t, e) {\n    this.debounce.error(t, e);\n  };\n\n  DebounceTask.prototype.dispose = function dispose() {};\n\n  return DebounceTask;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.\n * Event order is preserved. The stream will fail if any promise rejects.\n */\nvar awaitPromises = function awaitPromises(stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Await(stream);\n};\n\n/**\n * Create a stream containing only the promise's fulfillment\n * value at the time it fulfills.\n * @param {Promise<T>} p promise\n * @return {Stream<T>} stream containing promise's fulfillment value.\n *  If the promise rejects, the stream will error\n */\nvar fromPromise = /*#__PURE__*/compose(awaitPromises, now);\n\nvar Await = /*#__PURE__*/function () {\n  function Await(source) {\n    classCallCheck(this, Await);\n\n    this.source = source;\n  }\n\n  Await.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new AwaitSink(sink, scheduler$$1), scheduler$$1);\n  };\n\n  return Await;\n}();\n\nvar AwaitSink = /*#__PURE__*/function () {\n  function AwaitSink(sink, scheduler$$1) {\n    var _this = this;\n\n    classCallCheck(this, AwaitSink);\n\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.queue = Promise.resolve();\n\n    // Pre-create closures, to avoid creating them per event\n    this._eventBound = function (x) {\n      return _this.sink.event(currentTime(_this.scheduler), x);\n    };\n    this._endBound = function () {\n      return _this.sink.end(currentTime(_this.scheduler));\n    };\n    this._errorBound = function (e) {\n      return _this.sink.error(currentTime(_this.scheduler), e);\n    };\n  }\n\n  AwaitSink.prototype.event = function event(t, promise) {\n    var _this2 = this;\n\n    this.queue = this.queue.then(function () {\n      return _this2._event(promise);\n    }).catch(this._errorBound);\n  };\n\n  AwaitSink.prototype.end = function end(t) {\n    this.queue = this.queue.then(this._endBound).catch(this._errorBound);\n  };\n\n  AwaitSink.prototype.error = function error(t, e) {\n    var _this3 = this;\n\n    // Don't resolve error values, propagate directly\n    this.queue = this.queue.then(function () {\n      return _this3._errorBound(e);\n    }).catch(fatalError);\n  };\n\n  AwaitSink.prototype._event = function _event(promise) {\n    return promise.then(this._eventBound);\n  };\n\n  return AwaitSink;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar SafeSink = /*#__PURE__*/function () {\n  function SafeSink(sink) {\n    classCallCheck(this, SafeSink);\n\n    this.sink = sink;\n    this.active = true;\n  }\n\n  SafeSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.sink.event(t, x);\n  };\n\n  SafeSink.prototype.end = function end(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.disable();\n    this.sink.end(t, x);\n  };\n\n  SafeSink.prototype.error = function error(t, e) {\n    this.disable();\n    this.sink.error(t, e);\n  };\n\n  SafeSink.prototype.disable = function disable() {\n    this.active = false;\n    return this.sink;\n  };\n\n  return SafeSink;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction tryEvent(t, x, sink) {\n  try {\n    sink.event(t, x);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}\n\nfunction tryEnd(t, sink) {\n  try {\n    sink.end(t);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * If stream encounters an error, recover and continue with items from stream\n * returned by f.\n * @param {function(error:*):Stream} f function which returns a new stream\n * @param {Stream} stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\nvar recoverWith$1 = function recoverWith(f, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new RecoverWith(f, stream);\n};\n\n/**\n * Create a stream containing only an error\n * @param {*} e error value, preferably an Error or Error subtype\n * @returns {Stream} new stream containing only an error\n */\nvar throwError = function throwError(e) {\n  return new ErrorStream(e);\n};\n\nvar ErrorStream = /*#__PURE__*/function () {\n  function ErrorStream(e) {\n    classCallCheck(this, ErrorStream);\n\n    this.value = e;\n  }\n\n  ErrorStream.prototype.run = function run(sink, scheduler$$1) {\n    return asap(propagateErrorTask$1(this.value, sink), scheduler$$1);\n  };\n\n  return ErrorStream;\n}();\n\nvar RecoverWith = /*#__PURE__*/function () {\n  function RecoverWith(f, source) {\n    classCallCheck(this, RecoverWith);\n\n    this.f = f;\n    this.source = source;\n  }\n\n  RecoverWith.prototype.run = function run(sink, scheduler$$1) {\n    return new RecoverWithSink(this.f, this.source, sink, scheduler$$1);\n  };\n\n  return RecoverWith;\n}();\n\nvar RecoverWithSink = /*#__PURE__*/function () {\n  function RecoverWithSink(f, source, sink, scheduler$$1) {\n    classCallCheck(this, RecoverWithSink);\n\n    this.f = f;\n    this.sink = new SafeSink(sink);\n    this.scheduler = scheduler$$1;\n    this.disposable = source.run(this, scheduler$$1);\n  }\n\n  RecoverWithSink.prototype.event = function event(t, x) {\n    tryEvent(t, x, this.sink);\n  };\n\n  RecoverWithSink.prototype.end = function end(t) {\n    tryEnd(t, this.sink);\n  };\n\n  RecoverWithSink.prototype.error = function error(t, e) {\n    var nextSink = this.sink.disable();\n\n    tryDispose(t, this.disposable, this.sink);\n\n    this._startNext(t, e, nextSink);\n  };\n\n  RecoverWithSink.prototype._startNext = function _startNext(t, x, sink) {\n    try {\n      this.disposable = this._continue(this.f, t, x, sink);\n    } catch (e) {\n      sink.error(t, e);\n    }\n  };\n\n  RecoverWithSink.prototype._continue = function _continue(f, t, x, sink) {\n    return run$1(sink, this.scheduler, withLocalTime$1(t, f(x)));\n  };\n\n  RecoverWithSink.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return RecoverWithSink;\n}();\n\nvar multicast = function multicast(stream) {\n  return stream instanceof Multicast || isCanonicalEmpty(stream) ? stream : new Multicast(stream);\n};\n\nvar Multicast = /*#__PURE__*/function () {\n  function Multicast(source) {\n    classCallCheck(this, Multicast);\n\n    this.source = new MulticastSource(source);\n  }\n\n  Multicast.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(sink, scheduler$$1);\n  };\n\n  return Multicast;\n}();\n\nvar MulticastSource = /*#__PURE__*/function () {\n  function MulticastSource(source) {\n    classCallCheck(this, MulticastSource);\n\n    this.source = source;\n    this.sinks = [];\n    this.disposable = disposeNone();\n  }\n\n  MulticastSource.prototype.run = function run(sink, scheduler$$1) {\n    var n = this.add(sink);\n    if (n === 1) {\n      this.disposable = this.source.run(this, scheduler$$1);\n    }\n    return disposeOnce(new MulticastDisposable(this, sink));\n  };\n\n  MulticastSource.prototype.dispose = function dispose() {\n    var disposable$$1 = this.disposable;\n    this.disposable = disposeNone();\n    return disposable$$1.dispose();\n  };\n\n  MulticastSource.prototype.add = function add(sink) {\n    this.sinks = append(sink, this.sinks);\n    return this.sinks.length;\n  };\n\n  MulticastSource.prototype.remove = function remove$$1(sink) {\n    var i = findIndex(sink, this.sinks);\n    // istanbul ignore next\n    if (i >= 0) {\n      this.sinks = remove(i, this.sinks);\n    }\n\n    return this.sinks.length;\n  };\n\n  MulticastSource.prototype.event = function event(time, value) {\n    var s = this.sinks;\n    if (s.length === 1) {\n      return s[0].event(time, value);\n    }\n    for (var i = 0; i < s.length; ++i) {\n      tryEvent(time, value, s[i]);\n    }\n  };\n\n  MulticastSource.prototype.end = function end(time) {\n    var s = this.sinks;\n    for (var i = 0; i < s.length; ++i) {\n      tryEnd(time, s[i]);\n    }\n  };\n\n  MulticastSource.prototype.error = function error(time, err) {\n    var s = this.sinks;\n    for (var i = 0; i < s.length; ++i) {\n      s[i].error(time, err);\n    }\n  };\n\n  return MulticastSource;\n}();\n\nvar MulticastDisposable = /*#__PURE__*/function () {\n  function MulticastDisposable(source, sink) {\n    classCallCheck(this, MulticastDisposable);\n\n    this.source = source;\n    this.sink = sink;\n  }\n\n  MulticastDisposable.prototype.dispose = function dispose() {\n    if (this.source.remove(this.sink) === 0) {\n      this.source.dispose();\n    }\n  };\n\n  return MulticastDisposable;\n}();\n\n/** @license MIT License (c) copyright 2016 original author or authors */\n/* eslint-disable import/first */\nvar zipItems$$1 = /*#__PURE__*/curry3(zipItems$1);\nvar withItems$$1 = /*#__PURE__*/curry2(withItems$1);\n\n// -----------------------------------------------------------------------\n// Observing\n\nvar runEffects$$1 = /*#__PURE__*/curry2(runEffects$1);\nvar run$$1 = /*#__PURE__*/curry3(run$1);\n\n// -------------------------------------------------------\n\nvar withLocalTime$$1 = /*#__PURE__*/curry2(withLocalTime$1);\n\n// -------------------------------------------------------\n\nvar loop$$1 = /*#__PURE__*/curry3(loop$1);\n\n// -------------------------------------------------------\n\nvar scan$$1 = /*#__PURE__*/curry3(scan$1);\n\n// -----------------------------------------------------------------------\n// Extending\n\nvar startWith$$1 = /*#__PURE__*/curry2(startWith$1);\n\n// -----------------------------------------------------------------------\n// Transforming\n\nvar map$1 = /*#__PURE__*/curry2(map$2);\nvar constant$$1 = /*#__PURE__*/curry2(constant$1);\nvar tap$$1 = /*#__PURE__*/curry2(tap$1);\nvar ap$$1 = /*#__PURE__*/curry2(ap$1);\n\n// -----------------------------------------------------------------------\n// FlatMapping\n\nvar chain$$1 = /*#__PURE__*/curry2(chain$1);\nvar continueWith$$1 = /*#__PURE__*/curry2(continueWith$1);\n\nvar concatMap$$1 = /*#__PURE__*/curry2(concatMap$1);\n\n// -----------------------------------------------------------------------\n// Concurrent merging\n\nvar mergeConcurrently$$1 = /*#__PURE__*/curry2(mergeConcurrently$1);\nvar mergeMapConcurrently$$1 = /*#__PURE__*/curry3(mergeMapConcurrently$1);\n\n// -----------------------------------------------------------------------\n// Merging\n\nvar merge$$1 = /*#__PURE__*/curry2(merge$1);\n// -----------------------------------------------------------------------\n// Combining\n\nvar combine$$1 = /*#__PURE__*/curry3(combine$1);\nvar combineArray$$1 = /*#__PURE__*/curry2(combineArray$1);\n\n// -----------------------------------------------------------------------\n// Sampling\n\nvar sample$$1 = /*#__PURE__*/curry2(sample$1);\nvar snapshot$$1 = /*#__PURE__*/curry3(snapshot$1);\n\n// -----------------------------------------------------------------------\n// Zipping\n\nvar zip$$1 = /*#__PURE__*/curry3(zip$1);\nvar zipArray$$1 = /*#__PURE__*/curry2(zipArray$1);\n\n// -----------------------------------------------------------------------\n// Filtering\n\nvar filter$$1 = /*#__PURE__*/curry2(filter$1);\nvar skipRepeatsWith$$1 = /*#__PURE__*/curry2(skipRepeatsWith$1);\n\n// -----------------------------------------------------------------------\n// Slicing\n\nvar take$$1 = /*#__PURE__*/curry2(take$1);\nvar skip$$1 = /*#__PURE__*/curry2(skip$1);\nvar slice$$1 = /*#__PURE__*/curry3(slice$1);\nvar takeWhile$$1 = /*#__PURE__*/curry2(takeWhile$1);\nvar skipWhile$$1 = /*#__PURE__*/curry2(skipWhile$1);\nvar skipAfter$$1 = /*#__PURE__*/curry2(skipAfter$1);\n\n// -----------------------------------------------------------------------\n// Time slicing\n\nvar until$$1 = /*#__PURE__*/curry2(until$1);\nvar since$$1 = /*#__PURE__*/curry2(since$1);\nvar during$$1 = /*#__PURE__*/curry2(during$1);\n\n// -----------------------------------------------------------------------\n// Delaying\n\nvar delay$1 = /*#__PURE__*/curry2(delay$2);\n\n// -----------------------------------------------------------------------\n// Rate limiting\n\nvar throttle$$1 = /*#__PURE__*/curry2(throttle$1);\nvar debounce$$1 = /*#__PURE__*/curry2(debounce$1);\n\n// -----------------------------------------------------------------------\n// Error handling\n\nvar recoverWith$$1 = /*#__PURE__*/curry2(recoverWith$1);\n// ----------------------------------------------------------------------\nvar propagateTask$$1 = /*#__PURE__*/curry3(propagateTask$1);\nvar propagateEventTask$$1 = /*#__PURE__*/curry2(propagateEventTask$1);\nvar propagateErrorTask$$1 = /*#__PURE__*/curry2(propagateErrorTask$1);\n\nexport { zipItems$$1 as zipItems, withItems$$1 as withItems, runEffects$$1 as runEffects, run$$1 as run, withLocalTime$$1 as withLocalTime, loop$$1 as loop, scan$$1 as scan, startWith$$1 as startWith, map$1 as map, constant$$1 as constant, tap$$1 as tap, ap$$1 as ap, chain$$1 as chain, join, continueWith$$1 as continueWith, concatMap$$1 as concatMap, mergeConcurrently$$1 as mergeConcurrently, mergeMapConcurrently$$1 as mergeMapConcurrently, merge$$1 as merge, mergeArray, combine$$1 as combine, combineArray$$1 as combineArray, sample$$1 as sample, snapshot$$1 as snapshot, zip$$1 as zip, zipArray$$1 as zipArray, filter$$1 as filter, skipRepeats, skipRepeatsWith$$1 as skipRepeatsWith, take$$1 as take, skip$$1 as skip, slice$$1 as slice, takeWhile$$1 as takeWhile, skipWhile$$1 as skipWhile, skipAfter$$1 as skipAfter, until$$1 as until, since$$1 as since, during$$1 as during, delay$1 as delay, throttle$$1 as throttle, debounce$$1 as debounce, recoverWith$$1 as recoverWith, throwError, propagateTask$$1 as propagateTask, propagateEventTask$$1 as propagateEventTask, propagateErrorTask$$1 as propagateErrorTask, propagateEndTask, empty, never, now, at, periodic$1 as periodic, newStream, switchLatest, fromPromise, awaitPromises, multicast, MulticastSource };\n//# sourceMappingURL=index.es.js.map\n","import { currentTime } from '@most/scheduler';\n\n/** @license MIT License (c) copyright 2015-2016 original author or authors */\n/** @author Brian Cavalier */\n// domEvent :: (EventTarget t, Event e) => String -> t -> boolean=false -> Stream e\nvar domEvent = function (event, node, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    return new DomEvent(event, node, capture);\n};\n\nvar blur = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('blur', node, capture);\n};\nvar focus = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('focus', node, capture);\n};\nvar focusin = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('focusin', node, capture);\n};\nvar focusout = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('focusout', node, capture);\n};\nvar click = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('click', node, capture);\n};\nvar dblclick = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('dblclick', node, capture);\n};\nvar mousedown = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mousedown', node, capture);\n};\nvar mouseup = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mouseup', node, capture);\n};\nvar mousemove = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mousemove', node, capture);\n};\nvar mouseover = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mouseover', node, capture);\n};\nvar mouseenter = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mouseenter', node, capture);\n};\nvar mouseout = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mouseout', node, capture);\n};\nvar mouseleave = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('mouseleave', node, capture);\n};\nvar change = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('change', node, capture);\n};\nvar select = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('select', node, capture);\n};\nvar submit = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('submit', node, capture);\n};\nvar keydown = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('keydown', node, capture);\n};\nvar keypress = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('keypress', node, capture);\n};\nvar keyup = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('keyup', node, capture);\n};\nvar input = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('input', node, capture);\n};\nvar contextmenu = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('contextmenu', node, capture);\n};\nvar resize = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('resize', node, capture);\n};\nvar scroll = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('scroll', node, capture);\n};\nvar error = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('error', node, capture);\n};\n\nvar hashchange = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('hashchange', node, capture);\n};\nvar popstate = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('popstate', node, capture);\n};\nvar load = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('load', node, capture);\n};\nvar unload = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('unload', node, capture);\n};\n\nvar pointerdown = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointerdown', node, capture);\n};\nvar pointerup = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointerup', node, capture);\n};\nvar pointermove = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointermove', node, capture);\n};\nvar pointerover = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointerover', node, capture);\n};\nvar pointerenter = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointerenter', node, capture);\n};\nvar pointerout = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointerout', node, capture);\n};\nvar pointerleave = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('pointerleave', node, capture);\n};\n\nvar touchstart = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('touchstart', node, capture);\n};\nvar touchend = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('touchend', node, capture);\n};\nvar touchmove = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('touchmove', node, capture);\n};\nvar touchcancel = function (node, capture) {\n  if ( capture === void 0 ) capture = false;\n\n  return domEvent('touchcancel', node, capture);\n};\n\nvar DomEvent = function DomEvent (event, node, capture) {\n  this.event = event;\n  this.node = node;\n  this.capture = capture;\n};\n\nDomEvent.prototype.run = function run (sink, scheduler$$1) {\n    var this$1 = this;\n\n  var send = function (e) { return tryEvent(currentTime(scheduler$$1), e, sink); };\n  var dispose = function () { return this$1.node.removeEventListener(this$1.event, send, this$1.capture); };\n\n  this.node.addEventListener(this.event, send, this.capture);\n\n  return { dispose: dispose }\n};\n\nfunction tryEvent (t, x, sink) {\n  try {\n    sink.event(t, x);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}\n\nexport { domEvent, blur, focus, focusin, focusout, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseenter, mouseout, mouseleave, change, select, submit, keydown, keypress, keyup, input, contextmenu, resize, scroll, error, hashchange, popstate, load, unload, pointerdown, pointerup, pointermove, pointerover, pointerenter, pointerout, pointerleave, touchstart, touchend, touchmove, touchcancel };\n//# sourceMappingURL=index.es.js.map\n","import { append, apply, compose, curry2, curry3, findIndex, id, map, reduce, remove } from '@most/prelude';\nimport { asap, cancelAllTasks, currentTime, delay, periodic, schedulerRelativeTo } from '@most/scheduler';\nimport { disposeAll, disposeBoth, disposeNone, disposeOnce, tryDispose } from '@most/disposable';\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction fatalError(e) {\n  setTimeout(rethrow, 0, e);\n}\n\nfunction rethrow(e) {\n  throw e;\n}\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar propagateTask$1 = function propagateTask(run, value, sink) {\n  return new PropagateTask(run, value, sink);\n};\n\nvar propagateEventTask$1 = function propagateEventTask(value, sink) {\n  return propagateTask$1(runEvent, value, sink);\n};\n\nvar propagateEndTask = function propagateEndTask(sink) {\n  return propagateTask$1(runEnd, undefined, sink);\n};\n\nvar propagateErrorTask$1 = function propagateErrorTask(value, sink) {\n  return propagateTask$1(runError, value, sink);\n};\n\nvar PropagateTask = /*#__PURE__*/function () {\n  function PropagateTask(run, value, sink) {\n    classCallCheck(this, PropagateTask);\n\n    this._run = run;\n    this.value = value;\n    this.sink = sink;\n    this.active = true;\n  }\n\n  PropagateTask.prototype.dispose = function dispose() {\n    this.active = false;\n  };\n\n  PropagateTask.prototype.run = function run(t) {\n    if (!this.active) {\n      return;\n    }\n    var run = this._run;\n    run(t, this.value, this.sink);\n  };\n\n  PropagateTask.prototype.error = function error(t, e) {\n    // TODO: Remove this check and just do this.sink.error(t, e)?\n    if (!this.active) {\n      return fatalError(e);\n    }\n    this.sink.error(t, e);\n  };\n\n  return PropagateTask;\n}();\n\nvar runEvent = function runEvent(t, x, sink) {\n  return sink.event(t, x);\n};\n\nvar runEnd = function runEnd(t, _, sink) {\n  return sink.end(t);\n};\n\nvar runError = function runError(t, e, sink) {\n  return sink.error(t, e);\n};\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar empty = function empty() {\n  return EMPTY;\n};\n\nvar isCanonicalEmpty = function isCanonicalEmpty(stream) {\n  return stream === EMPTY;\n};\n\nvar containsCanonicalEmpty = function containsCanonicalEmpty(streams) {\n  return streams.some(isCanonicalEmpty);\n};\n\nvar Empty = /*#__PURE__*/function () {\n  function Empty() {\n    classCallCheck(this, Empty);\n  }\n\n  Empty.prototype.run = function run(sink, scheduler$$1) {\n    return asap(propagateEndTask(sink), scheduler$$1);\n  };\n\n  return Empty;\n}();\n\nvar EMPTY = /*#__PURE__*/new Empty();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar never = function never() {\n  return NEVER;\n};\n\nvar Never = /*#__PURE__*/function () {\n  function Never() {\n    classCallCheck(this, Never);\n  }\n\n  Never.prototype.run = function run() {\n    return disposeNone();\n  };\n\n  return Never;\n}();\n\nvar NEVER = /*#__PURE__*/new Never();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar at = function at(t, x) {\n  return new At(t, x);\n};\n\nvar At = /*#__PURE__*/function () {\n  function At(t, x) {\n    classCallCheck(this, At);\n\n    this.time = t;\n    this.value = x;\n  }\n\n  At.prototype.run = function run(sink, scheduler$$1) {\n    return delay(this.time, propagateTask$1(runAt, this.value, sink), scheduler$$1);\n  };\n\n  return At;\n}();\n\nfunction runAt(t, x, sink) {\n  sink.event(t, x);\n  sink.end(t);\n}\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar now = function now(x) {\n  return at(0, x);\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Create a stream of events that occur at a regular period\n * @param {Number} period periodicity of events\n * @returns {Stream} new stream of periodic events, the event value is undefined\n */\nvar periodic$1 = function periodic$$1(period) {\n  return new Periodic(period);\n};\n\nvar Periodic = /*#__PURE__*/function () {\n  function Periodic(period) {\n    classCallCheck(this, Periodic);\n\n    this.period = period;\n  }\n\n  Periodic.prototype.run = function run(sink, scheduler$$1) {\n    return periodic(this.period, propagateEventTask$1(undefined, sink), scheduler$$1);\n  };\n\n  return Periodic;\n}();\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar newStream = function newStream(run) {\n  return new Stream(run);\n};\n\nvar Stream = function Stream(run) {\n  classCallCheck(this, Stream);\n\n  this.run = run;\n};\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n/** @author Brian Cavalier */\n\nvar Pipe = /*#__PURE__*/function () {\n  function Pipe(sink) {\n    classCallCheck(this, Pipe);\n\n    this.sink = sink;\n  }\n\n  Pipe.prototype.event = function event(t, x) {\n    return this.sink.event(t, x);\n  };\n\n  Pipe.prototype.end = function end(t) {\n    return this.sink.end(t);\n  };\n\n  Pipe.prototype.error = function error(t, e) {\n    return this.sink.error(t, e);\n  };\n\n  return Pipe;\n}();\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n// A slice Bounds type that narrows min values via accumulation\n// and max values via Math.min.\n// type Bounds = { min: number, max: number }\n// Notes:\n// 0 <= min <= max\n// slice(min2, max2, slice(min1, max1, s)) ~ slice(min1 + min2, Math.min(max1, min1 + max2), s)\n// A bounds has a 1d coord system with origin 0, extending to Infinity.  Both min and max\n// are relative to the origin (0).  However, when merging bounds b1 and b2, we\n// *interpret* b2 as being relative to b1, hence adding min1 to *both* min2 and max2.\n// This essentially translates b2's coordinates back into origin coordinates\n// as bounds are merged.\n\n// Construct a constrained bounds\nvar boundsFrom = function boundsFrom(unsafeMin, unsafeMax) {\n  var min = Math.max(0, unsafeMin);\n  var max = Math.max(min, unsafeMax);\n  return { min: min, max: max };\n};\n\nvar minBounds = function minBounds(min) {\n  return boundsFrom(min, Infinity);\n};\n\nvar maxBounds = function maxBounds(max) {\n  return boundsFrom(0, max);\n};\n\n// Combine 2 bounds by narrowing min and max\nvar mergeBounds = function mergeBounds(b1, b2) {\n  return boundsFrom(b1.min + b2.min, Math.min(b1.max, b1.min + b2.max));\n};\n\n// Nil bounds excludes all slice indices\nvar isNilBounds = function isNilBounds(b) {\n  return b.min >= b.max;\n};\n\n// Infinite bounds includes all slice indices\nvar isInfiniteBounds = function isInfiniteBounds(b) {\n  return b.min <= 0 && b.max === Infinity;\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Filter = /*#__PURE__*/function () {\n  function Filter(p, source) {\n    classCallCheck(this, Filter);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  Filter.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new FilterSink(this.p, sink), scheduler$$1);\n  };\n\n  /**\n   * Create a filtered source, fusing adjacent filter.filter if possible\n   * @param {function(x:*):boolean} p filtering predicate\n   * @param {{run:function}} source source to filter\n   * @returns {Filter} filtered source\n   */\n\n\n  Filter.create = function create(p, source) {\n    if (isCanonicalEmpty(source)) {\n      return source;\n    }\n\n    if (source instanceof Filter) {\n      return new Filter(and(source.p, p), source.source);\n    }\n\n    return new Filter(p, source);\n  };\n\n  return Filter;\n}();\n\nvar FilterSink = /*#__PURE__*/function (_Pipe) {\n  inherits(FilterSink, _Pipe);\n\n  function FilterSink(p, sink) {\n    classCallCheck(this, FilterSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.p = p;\n    return _this;\n  }\n\n  FilterSink.prototype.event = function event(t, x) {\n    var p = this.p;\n    p(x) && this.sink.event(t, x);\n  };\n\n  return FilterSink;\n}(Pipe);\n\nvar and = function and(p, q) {\n  return function (x) {\n    return p(x) && q(x);\n  };\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar FilterMap = /*#__PURE__*/function () {\n  function FilterMap(p, f, source) {\n    classCallCheck(this, FilterMap);\n\n    this.p = p;\n    this.f = f;\n    this.source = source;\n  }\n\n  FilterMap.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler$$1);\n  };\n\n  return FilterMap;\n}();\n\nvar FilterMapSink = /*#__PURE__*/function (_Pipe) {\n  inherits(FilterMapSink, _Pipe);\n\n  function FilterMapSink(p, f, sink) {\n    classCallCheck(this, FilterMapSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.p = p;\n    _this.f = f;\n    return _this;\n  }\n\n  FilterMapSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    var p = this.p;\n    p(x) && this.sink.event(t, f(x));\n  };\n\n  return FilterMapSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar Map = /*#__PURE__*/function () {\n  function Map(f, source) {\n    classCallCheck(this, Map);\n\n    this.f = f;\n    this.source = source;\n  }\n\n  Map.prototype.run = function run(sink, scheduler$$1) {\n    // eslint-disable-line no-extend-native\n    return this.source.run(new MapSink(this.f, sink), scheduler$$1);\n  };\n\n  /**\n   * Create a mapped source, fusing adjacent map.map, filter.map,\n   * and filter.map.map if possible\n   * @param {function(*):*} f mapping function\n   * @param {{run:function}} source source to map\n   * @returns {Map|FilterMap} mapped source, possibly fused\n   */\n\n\n  Map.create = function create(f, source) {\n    if (isCanonicalEmpty(source)) {\n      return empty();\n    }\n\n    if (source instanceof Map) {\n      return new Map(compose(f, source.f), source.source);\n    }\n\n    if (source instanceof Filter) {\n      return new FilterMap(source.p, f, source.source);\n    }\n\n    return new Map(f, source);\n  };\n\n  return Map;\n}();\n\nvar MapSink = /*#__PURE__*/function (_Pipe) {\n  inherits(MapSink, _Pipe);\n\n  function MapSink(f, sink) {\n    classCallCheck(this, MapSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    return _this;\n  }\n\n  MapSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    this.sink.event(t, f(x));\n  };\n\n  return MapSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar SettableDisposable = /*#__PURE__*/function () {\n  function SettableDisposable() {\n    classCallCheck(this, SettableDisposable);\n\n    this.disposable = undefined;\n    this.disposed = false;\n  }\n\n  SettableDisposable.prototype.setDisposable = function setDisposable(disposable$$1) {\n    if (this.disposable !== void 0) {\n      throw new Error('setDisposable called more than once');\n    }\n\n    this.disposable = disposable$$1;\n\n    if (this.disposed) {\n      disposable$$1.dispose();\n    }\n  };\n\n  SettableDisposable.prototype.dispose = function dispose() {\n    if (this.disposed) {\n      return;\n    }\n\n    this.disposed = true;\n\n    if (this.disposable !== void 0) {\n      this.disposable.dispose();\n    }\n  };\n\n  return SettableDisposable;\n}();\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream containing only up to the first n items from stream\n */\nvar take$1 = function take(n, stream) {\n  return sliceBounds(maxBounds(n), stream);\n};\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream with the first n items removed\n */\nvar skip$1 = function skip(n, stream) {\n  return sliceBounds(minBounds(n), stream);\n};\n\n/**\n * Slice a stream by index. Negative start/end indexes are not supported\n * @param {number} start\n * @param {number} end\n * @param {Stream} stream\n * @returns {Stream} stream containing items where start <= index < end\n */\nvar slice$1 = function slice(start, end, stream) {\n  return sliceBounds(boundsFrom(start, end), stream);\n};\n\nvar sliceBounds = function sliceBounds(bounds, stream) {\n  return isSliceEmpty(bounds, stream) ? empty() : stream instanceof Map ? commuteMapSlice(bounds, stream) : stream instanceof Slice ? fuseSlice(bounds, stream) : createSlice(bounds, stream);\n};\n\nvar isSliceEmpty = function isSliceEmpty(bounds, stream) {\n  return isCanonicalEmpty(stream) || isNilBounds(bounds);\n};\n\nvar createSlice = function createSlice(bounds, stream) {\n  return isInfiniteBounds(bounds) ? stream : new Slice(bounds, stream);\n};\n\nvar commuteMapSlice = function commuteMapSlice(bounds, mapStream) {\n  return Map.create(mapStream.f, sliceBounds(bounds, mapStream.source));\n};\n\nvar fuseSlice = function fuseSlice(bounds, sliceStream) {\n  return sliceBounds(mergeBounds(bounds, sliceStream.bounds), sliceStream.source);\n};\n\nvar Slice = /*#__PURE__*/function () {\n  function Slice(bounds, source) {\n    classCallCheck(this, Slice);\n\n    this.source = source;\n    this.bounds = bounds;\n  }\n\n  Slice.prototype.run = function run(sink, scheduler$$1) {\n    var disposable$$1 = new SettableDisposable();\n    var sliceSink = new SliceSink(this.bounds.min, this.bounds.max - this.bounds.min, sink, disposable$$1);\n\n    disposable$$1.setDisposable(this.source.run(sliceSink, scheduler$$1));\n\n    return disposable$$1;\n  };\n\n  return Slice;\n}();\n\nvar SliceSink = /*#__PURE__*/function (_Pipe) {\n  inherits(SliceSink, _Pipe);\n\n  function SliceSink(skip, take, sink, disposable$$1) {\n    classCallCheck(this, SliceSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.skip = skip;\n    _this.take = take;\n    _this.disposable = disposable$$1;\n    return _this;\n  }\n\n  SliceSink.prototype.event = function event(t, x) {\n    /* eslint complexity: [1, 4] */\n    if (this.skip > 0) {\n      this.skip -= 1;\n      return;\n    }\n\n    if (this.take === 0) {\n      return;\n    }\n\n    this.take -= 1;\n    this.sink.event(t, x);\n    if (this.take === 0) {\n      this.disposable.dispose();\n      this.sink.end(t);\n    }\n  };\n\n  return SliceSink;\n}(Pipe);\n\nvar takeWhile$1 = function takeWhile(p, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new TakeWhile(p, stream);\n};\n\nvar TakeWhile = /*#__PURE__*/function () {\n  function TakeWhile(p, source) {\n    classCallCheck(this, TakeWhile);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  TakeWhile.prototype.run = function run(sink, scheduler$$1) {\n    var disposable$$1 = new SettableDisposable();\n    var takeWhileSink = new TakeWhileSink(this.p, sink, disposable$$1);\n\n    disposable$$1.setDisposable(this.source.run(takeWhileSink, scheduler$$1));\n\n    return disposable$$1;\n  };\n\n  return TakeWhile;\n}();\n\nvar TakeWhileSink = /*#__PURE__*/function (_Pipe2) {\n  inherits(TakeWhileSink, _Pipe2);\n\n  function TakeWhileSink(p, sink, disposable$$1) {\n    classCallCheck(this, TakeWhileSink);\n\n    var _this2 = possibleConstructorReturn(this, _Pipe2.call(this, sink));\n\n    _this2.p = p;\n    _this2.active = true;\n    _this2.disposable = disposable$$1;\n    return _this2;\n  }\n\n  TakeWhileSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n\n    var p = this.p;\n    this.active = p(x);\n\n    if (this.active) {\n      this.sink.event(t, x);\n    } else {\n      this.disposable.dispose();\n      this.sink.end(t);\n    }\n  };\n\n  return TakeWhileSink;\n}(Pipe);\n\nvar skipWhile$1 = function skipWhile(p, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new SkipWhile(p, stream);\n};\n\nvar SkipWhile = /*#__PURE__*/function () {\n  function SkipWhile(p, source) {\n    classCallCheck(this, SkipWhile);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  SkipWhile.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new SkipWhileSink(this.p, sink), scheduler$$1);\n  };\n\n  return SkipWhile;\n}();\n\nvar SkipWhileSink = /*#__PURE__*/function (_Pipe3) {\n  inherits(SkipWhileSink, _Pipe3);\n\n  function SkipWhileSink(p, sink) {\n    classCallCheck(this, SkipWhileSink);\n\n    var _this3 = possibleConstructorReturn(this, _Pipe3.call(this, sink));\n\n    _this3.p = p;\n    _this3.skipping = true;\n    return _this3;\n  }\n\n  SkipWhileSink.prototype.event = function event(t, x) {\n    if (this.skipping) {\n      var p = this.p;\n      this.skipping = p(x);\n      if (this.skipping) {\n        return;\n      }\n    }\n\n    this.sink.event(t, x);\n  };\n\n  return SkipWhileSink;\n}(Pipe);\n\nvar skipAfter$1 = function skipAfter(p, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new SkipAfter(p, stream);\n};\n\nvar SkipAfter = /*#__PURE__*/function () {\n  function SkipAfter(p, source) {\n    classCallCheck(this, SkipAfter);\n\n    this.p = p;\n    this.source = source;\n  }\n\n  SkipAfter.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new SkipAfterSink(this.p, sink), scheduler$$1);\n  };\n\n  return SkipAfter;\n}();\n\nvar SkipAfterSink = /*#__PURE__*/function (_Pipe4) {\n  inherits(SkipAfterSink, _Pipe4);\n\n  function SkipAfterSink(p, sink) {\n    classCallCheck(this, SkipAfterSink);\n\n    var _this4 = possibleConstructorReturn(this, _Pipe4.call(this, sink));\n\n    _this4.p = p;\n    _this4.skipping = false;\n    return _this4;\n  }\n\n  SkipAfterSink.prototype.event = function event(t, x) {\n    if (this.skipping) {\n      return;\n    }\n\n    var p = this.p;\n    this.skipping = p(x);\n    this.sink.event(t, x);\n\n    if (this.skipping) {\n      this.sink.end(t);\n    }\n  };\n\n  return SkipAfterSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2017 original author or authors */\n\nvar withItems$1 = function withItems(items, stream) {\n  return zipItems$1(keepLeft, items, stream);\n};\n\nvar zipItems$1 = function zipItems(f, items, stream) {\n  return isCanonicalEmpty(stream) || items.length === 0 ? empty() : new ZipItems(f, items, take$1(items.length, stream));\n};\n\nvar keepLeft = function keepLeft(a, _) {\n  return a;\n};\n\nvar ZipItems = /*#__PURE__*/function () {\n  function ZipItems(f, items, source) {\n    classCallCheck(this, ZipItems);\n\n    this.f = f;\n    this.items = items;\n    this.source = source;\n  }\n\n  ZipItems.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new ZipItemsSink(this.f, this.items, sink), scheduler$$1);\n  };\n\n  return ZipItems;\n}();\n\nvar ZipItemsSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ZipItemsSink, _Pipe);\n\n  function ZipItemsSink(f, items, sink) {\n    classCallCheck(this, ZipItemsSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.items = items;\n    _this.index = 0;\n    return _this;\n  }\n\n  ZipItemsSink.prototype.event = function event(t, b) {\n    var f = this.f;\n    this.sink.event(t, f(this.items[this.index], b));\n    this.index += 1;\n  };\n\n  return ZipItemsSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar runEffects$1 = /*#__PURE__*/curry2(function (stream, scheduler$$1) {\n  return new Promise(function (resolve, reject) {\n    return runStream(stream, scheduler$$1, resolve, reject);\n  });\n});\n\nfunction runStream(stream, scheduler$$1, resolve, reject) {\n  var disposable$$1 = new SettableDisposable();\n  var observer = new RunEffectsSink(resolve, reject, disposable$$1);\n\n  disposable$$1.setDisposable(stream.run(observer, scheduler$$1));\n}\n\nvar RunEffectsSink = /*#__PURE__*/function () {\n  function RunEffectsSink(end, error, disposable$$1) {\n    classCallCheck(this, RunEffectsSink);\n\n    this._end = end;\n    this._error = error;\n    this._disposable = disposable$$1;\n    this.active = true;\n  }\n\n  RunEffectsSink.prototype.event = function event(t, x) {};\n\n  RunEffectsSink.prototype.end = function end(t) {\n    if (!this.active) {\n      return;\n    }\n    this._dispose(this._error, this._end, undefined);\n  };\n\n  RunEffectsSink.prototype.error = function error(t, e) {\n    this._dispose(this._error, this._error, e);\n  };\n\n  RunEffectsSink.prototype._dispose = function _dispose(error, end, x) {\n    this.active = false;\n    tryDispose$1(error, end, x, this._disposable);\n  };\n\n  return RunEffectsSink;\n}();\n\nfunction tryDispose$1(error, end, x, disposable$$1) {\n  try {\n    disposable$$1.dispose();\n  } catch (e) {\n    error(e);\n    return;\n  }\n\n  end(x);\n}\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\n// Run a Stream, sending all its events to the\n// provided Sink.\nvar run$1 = function run(sink, scheduler$$1, stream) {\n    return stream.run(sink, scheduler$$1);\n};\n\nvar RelativeSink = /*#__PURE__*/function () {\n  function RelativeSink(offset, sink) {\n    classCallCheck(this, RelativeSink);\n\n    this.sink = sink;\n    this.offset = offset;\n  }\n\n  RelativeSink.prototype.event = function event(t, x) {\n    this.sink.event(t + this.offset, x);\n  };\n\n  RelativeSink.prototype.error = function error(t, e) {\n    this.sink.error(t + this.offset, e);\n  };\n\n  RelativeSink.prototype.end = function end(t) {\n    this.sink.end(t + this.offset);\n  };\n\n  return RelativeSink;\n}();\n\n// Create a stream with its own local clock\n// This transforms time from the provided scheduler's clock to a stream-local\n// clock (which starts at 0), and then *back* to the scheduler's clock before\n// propagating events to sink.  In other words, upstream sources will see local times,\n// and downstream sinks will see non-local (original) times.\nvar withLocalTime$1 = function withLocalTime(origin, stream) {\n  return new WithLocalTime(origin, stream);\n};\n\nvar WithLocalTime = /*#__PURE__*/function () {\n  function WithLocalTime(origin, source) {\n    classCallCheck(this, WithLocalTime);\n\n    this.origin = origin;\n    this.source = source;\n  }\n\n  WithLocalTime.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(relativeSink(this.origin, sink), schedulerRelativeTo(this.origin, scheduler$$1));\n  };\n\n  return WithLocalTime;\n}();\n\n// Accumulate offsets instead of nesting RelativeSinks, which can happen\n// with higher-order stream and combinators like continueWith when they're\n// applied recursively.\n\n\nvar relativeSink = function relativeSink(origin, sink) {\n  return sink instanceof RelativeSink ? new RelativeSink(origin + sink.offset, sink.sink) : new RelativeSink(origin, sink);\n};\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @param {Stream} stream event stream\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nvar loop$1 = function loop(stepper, seed, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Loop(stepper, seed, stream);\n};\n\nvar Loop = /*#__PURE__*/function () {\n  function Loop(stepper, seed, source) {\n    classCallCheck(this, Loop);\n\n    this.step = stepper;\n    this.seed = seed;\n    this.source = source;\n  }\n\n  Loop.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler$$1);\n  };\n\n  return Loop;\n}();\n\nvar LoopSink = /*#__PURE__*/function (_Pipe) {\n  inherits(LoopSink, _Pipe);\n\n  function LoopSink(stepper, seed, sink) {\n    classCallCheck(this, LoopSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.step = stepper;\n    _this.seed = seed;\n    return _this;\n  }\n\n  LoopSink.prototype.event = function event(t, x) {\n    var result = this.step(this.seed, x);\n    this.seed = result.seed;\n    this.sink.event(t, result.value);\n  };\n\n  return LoopSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @param {Stream} stream stream to scan\n * @returns {Stream} new stream containing successive reduce results\n */\nvar scan$1 = function scan(f, initial, stream) {\n  return new Scan(f, initial, stream);\n};\n\nvar Scan = /*#__PURE__*/function () {\n  function Scan(f, z, source) {\n    classCallCheck(this, Scan);\n\n    this.source = source;\n    this.f = f;\n    this.value = z;\n  }\n\n  Scan.prototype.run = function run(sink, scheduler$$1) {\n    var d1 = asap(propagateEventTask$1(this.value, sink), scheduler$$1);\n    var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler$$1);\n    return disposeBoth(d1, d2);\n  };\n\n  return Scan;\n}();\n\nvar ScanSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ScanSink, _Pipe);\n\n  function ScanSink(f, z, sink) {\n    classCallCheck(this, ScanSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.value = z;\n    return _this;\n  }\n\n  ScanSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    this.value = f(this.value, x);\n    this.sink.event(t, this.value);\n  };\n\n  return ScanSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar continueWith$1 = function continueWith(f, stream) {\n  return new ContinueWith(f, stream);\n};\n\nvar ContinueWith = /*#__PURE__*/function () {\n  function ContinueWith(f, source) {\n    classCallCheck(this, ContinueWith);\n\n    this.f = f;\n    this.source = source;\n  }\n\n  ContinueWith.prototype.run = function run(sink, scheduler$$1) {\n    return new ContinueWithSink(this.f, this.source, sink, scheduler$$1);\n  };\n\n  return ContinueWith;\n}();\n\nvar ContinueWithSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ContinueWithSink, _Pipe);\n\n  function ContinueWithSink(f, source, sink, scheduler$$1) {\n    classCallCheck(this, ContinueWithSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.scheduler = scheduler$$1;\n    _this.active = true;\n    _this.disposable = disposeOnce(source.run(_this, scheduler$$1));\n    return _this;\n  }\n\n  ContinueWithSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.sink.event(t, x);\n  };\n\n  ContinueWithSink.prototype.end = function end(t) {\n    if (!this.active) {\n      return;\n    }\n\n    tryDispose(t, this.disposable, this.sink);\n\n    this._startNext(t, this.sink);\n  };\n\n  ContinueWithSink.prototype._startNext = function _startNext(t, sink) {\n    try {\n      this.disposable = this._continue(this.f, t, sink);\n    } catch (e) {\n      sink.error(t, e);\n    }\n  };\n\n  ContinueWithSink.prototype._continue = function _continue(f, t, sink) {\n    return run$1(sink, this.scheduler, withLocalTime$1(t, f()));\n  };\n\n  ContinueWithSink.prototype.dispose = function dispose() {\n    this.active = false;\n    return this.disposable.dispose();\n  };\n\n  return ContinueWithSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nvar startWith$1 = function startWith(x, stream) {\n  return continueWith$1(function () {\n    return stream;\n  }, now(x));\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @param {Stream} stream stream to map\n * @returns {Stream} stream containing items transformed by f\n */\nvar map$2 = function map$$1(f, stream) {\n  return Map.create(f, stream);\n};\n\n/**\n* Replace each value in the stream with x\n* @param {*} x\n* @param {Stream} stream\n* @returns {Stream} stream containing items replaced with x\n*/\nvar constant$1 = function constant(x, stream) {\n  return map$2(function () {\n    return x;\n  }, stream);\n};\n\n/**\n* Perform a side effect for each item in the stream\n* @param {function(x:*):*} f side effect to execute for each item. The\n*  return value will be discarded.\n* @param {Stream} stream stream to tap\n* @returns {Stream} new stream containing the same items as this stream\n*/\nvar tap$1 = function tap(f, stream) {\n  return new Tap(f, stream);\n};\n\nvar Tap = /*#__PURE__*/function () {\n  function Tap(f, source) {\n    classCallCheck(this, Tap);\n\n    this.source = source;\n    this.f = f;\n  }\n\n  Tap.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new TapSink(this.f, sink), scheduler$$1);\n  };\n\n  return Tap;\n}();\n\nvar TapSink = /*#__PURE__*/function (_Pipe) {\n  inherits(TapSink, _Pipe);\n\n  function TapSink(f, sink) {\n    classCallCheck(this, TapSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    return _this;\n  }\n\n  TapSink.prototype.event = function event(t, x) {\n    var f = this.f;\n    f(x);\n    this.sink.event(t, x);\n  };\n\n  return TapSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar IndexSink = /*#__PURE__*/function (_Sink) {\n  inherits(IndexSink, _Sink);\n\n  function IndexSink(i, sink) {\n    classCallCheck(this, IndexSink);\n\n    var _this = possibleConstructorReturn(this, _Sink.call(this, sink));\n\n    _this.index = i;\n    _this.active = true;\n    _this.value = undefined;\n    return _this;\n  }\n\n  IndexSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.value = x;\n    this.sink.event(t, this);\n  };\n\n  IndexSink.prototype.end = function end(t) {\n    if (!this.active) {\n      return;\n    }\n    this.active = false;\n    this.sink.event(t, this);\n  };\n\n  return IndexSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction invoke(f, args) {\n  /* eslint complexity: [2,7] */\n  switch (args.length) {\n    case 0:\n      return f();\n    case 1:\n      return f(args[0]);\n    case 2:\n      return f(args[0], args[1]);\n    case 3:\n      return f(args[0], args[1], args[2]);\n    case 4:\n      return f(args[0], args[1], args[2], args[3]);\n    case 5:\n      return f(args[0], args[1], args[2], args[3], args[4]);\n    default:\n      return f.apply(void 0, args);\n  }\n}\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Combine latest events from two streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nvar combine$1 = function combine(f, stream1, stream2) {\n  return combineArray$1(f, [stream1, stream2]);\n};\n\n/**\n* Combine latest events from all input streams\n* @param {function(...events):*} f function to combine most recent events\n* @param {[Stream]} streams most recent events\n* @returns {Stream} stream containing the result of applying f to the most recent\n*  event of each input stream, whenever a new event arrives on any stream.\n*/\nvar combineArray$1 = function combineArray(f, streams) {\n  return streams.length === 0 || containsCanonicalEmpty(streams) ? empty() : streams.length === 1 ? map$2(f, streams[0]) : new Combine(f, streams);\n};\n\nvar Combine = /*#__PURE__*/function () {\n  function Combine(f, sources) {\n    classCallCheck(this, Combine);\n\n    this.f = f;\n    this.sources = sources;\n  }\n\n  Combine.prototype.run = function run(sink, scheduler$$1) {\n    var l = this.sources.length;\n    var disposables = new Array(l);\n    var sinks = new Array(l);\n\n    var mergeSink = new CombineSink(disposables, sinks, sink, this.f);\n\n    for (var indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink);\n      disposables[i] = this.sources[i].run(indexSink, scheduler$$1);\n    }\n\n    return disposeAll(disposables);\n  };\n\n  return Combine;\n}();\n\nvar CombineSink = /*#__PURE__*/function (_Pipe) {\n  inherits(CombineSink, _Pipe);\n\n  function CombineSink(disposables, sinks, sink, f) {\n    classCallCheck(this, CombineSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.disposables = disposables;\n    _this.sinks = sinks;\n    _this.f = f;\n\n    var l = sinks.length;\n    _this.awaiting = l;\n    _this.values = new Array(l);\n    _this.hasValue = new Array(l).fill(false);\n    _this.activeCount = sinks.length;\n    return _this;\n  }\n\n  CombineSink.prototype.event = function event(t, indexedValue) {\n    if (!indexedValue.active) {\n      this._dispose(t, indexedValue.index);\n      return;\n    }\n\n    var i = indexedValue.index;\n    var awaiting = this._updateReady(i);\n\n    this.values[i] = indexedValue.value;\n    if (awaiting === 0) {\n      this.sink.event(t, invoke(this.f, this.values));\n    }\n  };\n\n  CombineSink.prototype._updateReady = function _updateReady(index) {\n    if (this.awaiting > 0) {\n      if (!this.hasValue[index]) {\n        this.hasValue[index] = true;\n        this.awaiting -= 1;\n      }\n    }\n    return this.awaiting;\n  };\n\n  CombineSink.prototype._dispose = function _dispose(t, index) {\n    tryDispose(t, this.disposables[index], this.sink);\n    if (--this.activeCount === 0) {\n      this.sink.end(t);\n    }\n  };\n\n  return CombineSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Assume fs is a stream containing functions, and apply the latest function\n * in fs to the latest value in xs.\n * fs:         --f---------g--------h------>\n * xs:         -a-------b-------c-------d-->\n * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->\n * @param {Stream} fs stream of functions to apply to the latest x\n * @param {Stream} xs stream of values to which to apply all the latest f\n * @returns {Stream} stream containing all the applications of fs to xs\n */\nfunction ap$1(fs, xs) {\n  return combine$1(apply, fs, xs);\n}\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Doubly linked list\n * @constructor\n */\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    classCallCheck(this, LinkedList);\n\n    this.head = null;\n    this.length = 0;\n  }\n\n  /**\n   * Add a node to the end of the list\n   * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to add\n   */\n\n\n  LinkedList.prototype.add = function add(x) {\n    if (this.head !== null) {\n      this.head.prev = x;\n      x.next = this.head;\n    }\n    this.head = x;\n    ++this.length;\n  };\n\n  /**\n   * Remove the provided node from the list\n   * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to remove\n   */\n\n\n  LinkedList.prototype.remove = function remove$$1(x) {\n    // eslint-disable-line  complexity\n    --this.length;\n    if (x === this.head) {\n      this.head = this.head.next;\n    }\n    if (x.next !== null) {\n      x.next.prev = x.prev;\n      x.next = null;\n    }\n    if (x.prev !== null) {\n      x.prev.next = x.next;\n      x.prev = null;\n    }\n  };\n\n  /**\n   * @returns {boolean} true iff there are no nodes in the list\n   */\n\n\n  LinkedList.prototype.isEmpty = function isEmpty() {\n    return this.length === 0;\n  };\n\n  /**\n   * Dispose all nodes\n   * @returns {void}\n   */\n\n\n  LinkedList.prototype.dispose = function dispose() {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    var head = this.head;\n    this.head = null;\n    this.length = 0;\n\n    while (head !== null) {\n      head.dispose();\n      head = head.next;\n    }\n  };\n\n  return LinkedList;\n}();\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\nvar mergeConcurrently$1 = function mergeConcurrently(concurrency, stream) {\n  return mergeMapConcurrently$1(id, concurrency, stream);\n};\n\nvar mergeMapConcurrently$1 = function mergeMapConcurrently(f, concurrency, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new MergeConcurrently(f, concurrency, stream);\n};\n\nvar MergeConcurrently = /*#__PURE__*/function () {\n  function MergeConcurrently(f, concurrency, source) {\n    classCallCheck(this, MergeConcurrently);\n\n    this.f = f;\n    this.concurrency = concurrency;\n    this.source = source;\n  }\n\n  MergeConcurrently.prototype.run = function run(sink, scheduler$$1) {\n    return new Outer(this.f, this.concurrency, this.source, sink, scheduler$$1);\n  };\n\n  return MergeConcurrently;\n}();\n\nvar Outer = /*#__PURE__*/function () {\n  function Outer(f, concurrency, source, sink, scheduler$$1) {\n    classCallCheck(this, Outer);\n\n    this.f = f;\n    this.concurrency = concurrency;\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.pending = [];\n    this.current = new LinkedList();\n    this.disposable = disposeOnce(source.run(this, scheduler$$1));\n    this.active = true;\n  }\n\n  Outer.prototype.event = function event(t, x) {\n    this._addInner(t, x);\n  };\n\n  Outer.prototype._addInner = function _addInner(t, x) {\n    if (this.current.length < this.concurrency) {\n      this._startInner(t, x);\n    } else {\n      this.pending.push(x);\n    }\n  };\n\n  Outer.prototype._startInner = function _startInner(t, x) {\n    try {\n      this._initInner(t, x);\n    } catch (e) {\n      this.error(t, e);\n    }\n  };\n\n  Outer.prototype._initInner = function _initInner(t, x) {\n    var innerSink = new Inner(t, this, this.sink);\n    innerSink.disposable = mapAndRun(this.f, t, x, innerSink, this.scheduler);\n    this.current.add(innerSink);\n  };\n\n  Outer.prototype.end = function end(t) {\n    this.active = false;\n    tryDispose(t, this.disposable, this.sink);\n    this._checkEnd(t);\n  };\n\n  Outer.prototype.error = function error(t, e) {\n    this.active = false;\n    this.sink.error(t, e);\n  };\n\n  Outer.prototype.dispose = function dispose() {\n    this.active = false;\n    this.pending.length = 0;\n    this.disposable.dispose();\n    this.current.dispose();\n  };\n\n  Outer.prototype._endInner = function _endInner(t, inner) {\n    this.current.remove(inner);\n    tryDispose(t, inner, this);\n\n    if (this.pending.length === 0) {\n      this._checkEnd(t);\n    } else {\n      this._startInner(t, this.pending.shift());\n    }\n  };\n\n  Outer.prototype._checkEnd = function _checkEnd(t) {\n    if (!this.active && this.current.isEmpty()) {\n      this.sink.end(t);\n    }\n  };\n\n  return Outer;\n}();\n\nvar mapAndRun = function mapAndRun(f, t, x, sink, scheduler$$1) {\n  return f(x).run(sink, schedulerRelativeTo(t, scheduler$$1));\n};\n\nvar Inner = /*#__PURE__*/function () {\n  function Inner(time, outer, sink) {\n    classCallCheck(this, Inner);\n\n    this.prev = this.next = null;\n    this.time = time;\n    this.outer = outer;\n    this.sink = sink;\n    this.disposable = void 0;\n  }\n\n  Inner.prototype.event = function event(t, x) {\n    this.sink.event(t + this.time, x);\n  };\n\n  Inner.prototype.end = function end(t) {\n    this.outer._endInner(t + this.time, this);\n  };\n\n  Inner.prototype.error = function error(t, e) {\n    this.outer.error(t + this.time, e);\n  };\n\n  Inner.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return Inner;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nvar chain$1 = function chain(f, stream) {\n  return mergeMapConcurrently$1(f, Infinity, stream);\n};\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @param {Stream<Stream<X>>} stream stream of streams\n * @returns {Stream<X>} new stream containing all events of all inner streams\n */\nvar join = function join(stream) {\n  return mergeConcurrently$1(Infinity, stream);\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Map each value in stream to a new stream, and concatenate them all\n * stream:              -a---b---cX\n * f(a):                 1-1-1-1X\n * f(b):                        -2-2-2-2X\n * f(c):                                -3-3-3-3X\n * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X\n * @param {function(x:*):Stream} f function to map each value to a stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nvar concatMap$1 = function concatMap(f, stream) {\n  return mergeMapConcurrently$1(f, 1, stream);\n};\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * @returns {Stream} stream containing events from two streams in time order.\n * If two events are simultaneous they will be merged in arbitrary order.\n */\nfunction merge$1(stream1, stream2) {\n  return mergeArray([stream1, stream2]);\n}\n\n/**\n * @param {Array} streams array of stream to merge\n * @returns {Stream} stream containing events from all input observables\n * in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nvar mergeArray = function mergeArray(streams) {\n  return mergeStreams(withoutCanonicalEmpty(streams));\n};\n\n/**\n * This implements fusion/flattening for merge.  It will\n * fuse adjacent merge operations.  For example:\n * - a.merge(b).merge(c) effectively becomes merge(a, b, c)\n * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)\n * It does this by concatenating the sources arrays of\n * any nested Merge sources, in effect \"flattening\" nested\n * merge operations into a single merge.\n */\nvar mergeStreams = function mergeStreams(streams) {\n  return streams.length === 0 ? empty() : streams.length === 1 ? streams[0] : new Merge(reduce(appendSources, [], streams));\n};\n\nvar withoutCanonicalEmpty = function withoutCanonicalEmpty(streams) {\n  return streams.filter(isNotCanonicalEmpty);\n};\n\nvar isNotCanonicalEmpty = function isNotCanonicalEmpty(stream) {\n  return !isCanonicalEmpty(stream);\n};\n\nvar appendSources = function appendSources(sources, stream) {\n  return sources.concat(stream instanceof Merge ? stream.sources : stream);\n};\n\nvar Merge = /*#__PURE__*/function () {\n  function Merge(sources) {\n    classCallCheck(this, Merge);\n\n    this.sources = sources;\n  }\n\n  Merge.prototype.run = function run(sink, scheduler$$1) {\n    var l = this.sources.length;\n    var disposables = new Array(l);\n    var sinks = new Array(l);\n\n    var mergeSink = new MergeSink(disposables, sinks, sink);\n\n    for (var indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink);\n      disposables[i] = this.sources[i].run(indexSink, scheduler$$1);\n    }\n\n    return disposeAll(disposables);\n  };\n\n  return Merge;\n}();\n\nvar MergeSink = /*#__PURE__*/function (_Pipe) {\n  inherits(MergeSink, _Pipe);\n\n  function MergeSink(disposables, sinks, sink) {\n    classCallCheck(this, MergeSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.disposables = disposables;\n    _this.activeCount = sinks.length;\n    return _this;\n  }\n\n  MergeSink.prototype.event = function event(t, indexValue) {\n    if (!indexValue.active) {\n      this._dispose(t, indexValue.index);\n      return;\n    }\n    this.sink.event(t, indexValue.value);\n  };\n\n  MergeSink.prototype._dispose = function _dispose(t, index) {\n    tryDispose(t, this.disposables[index], this.sink);\n    if (--this.activeCount === 0) {\n      this.sink.end(t);\n    }\n  };\n\n  return MergeSink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\nvar sample$1 = function sample(values, sampler) {\n  return snapshot$1(function (x, _) {\n    return x;\n  }, values, sampler);\n};\n\nvar snapshot$1 = function snapshot(f, values, sampler) {\n  return isCanonicalEmpty(sampler) || isCanonicalEmpty(values) ? empty() : new Snapshot(f, values, sampler);\n};\n\nvar Snapshot = /*#__PURE__*/function () {\n  function Snapshot(f, values, sampler) {\n    classCallCheck(this, Snapshot);\n\n    this.f = f;\n    this.values = values;\n    this.sampler = sampler;\n  }\n\n  Snapshot.prototype.run = function run(sink, scheduler$$1) {\n    var sampleSink = new SnapshotSink(this.f, sink);\n    var valuesDisposable = this.values.run(sampleSink.latest, scheduler$$1);\n    var samplerDisposable = this.sampler.run(sampleSink, scheduler$$1);\n\n    return disposeBoth(samplerDisposable, valuesDisposable);\n  };\n\n  return Snapshot;\n}();\n\nvar SnapshotSink = /*#__PURE__*/function (_Pipe) {\n  inherits(SnapshotSink, _Pipe);\n\n  function SnapshotSink(f, sink) {\n    classCallCheck(this, SnapshotSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.latest = new LatestValueSink(_this);\n    return _this;\n  }\n\n  SnapshotSink.prototype.event = function event(t, x) {\n    if (this.latest.hasValue) {\n      var f = this.f;\n      this.sink.event(t, f(this.latest.value, x));\n    }\n  };\n\n  return SnapshotSink;\n}(Pipe);\n\nvar LatestValueSink = /*#__PURE__*/function (_Pipe2) {\n  inherits(LatestValueSink, _Pipe2);\n\n  function LatestValueSink(sink) {\n    classCallCheck(this, LatestValueSink);\n\n    var _this2 = possibleConstructorReturn(this, _Pipe2.call(this, sink));\n\n    _this2.hasValue = false;\n    return _this2;\n  }\n\n  LatestValueSink.prototype.event = function event(t, x) {\n    this.value = x;\n    this.hasValue = true;\n  };\n\n  LatestValueSink.prototype.end = function end() {};\n\n  return LatestValueSink;\n}(Pipe);\n\n// Copied and modified from https://github.com/invertase/denque\n// MIT License\n\n// These constants were extracted directly from denque's shift()\n// It's not clear exactly why the authors chose these particular\n// values, but given denque's stated goals, it seems likely that\n// they were chosen for speed/memory reasons.\n\n// Max value of _head at which Queue is willing to shink\n// its internal array\nvar HEAD_MAX_SHRINK = 2;\n\n// Min value of _tail at which Queue is willing to shink\n// its internal array\nvar TAIL_MIN_SHRINK = 10000;\n\nvar Queue = /*#__PURE__*/function () {\n  function Queue() {\n    classCallCheck(this, Queue);\n\n    this._head = 0;\n    this._tail = 0;\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n\n  Queue.prototype.push = function push(x) {\n    var tail = this._tail;\n    this._list[tail] = x;\n    this._tail = tail + 1 & this._capacityMask;\n    if (this._tail === this._head) {\n      this._growArray();\n    }\n\n    if (this._head < this._tail) {\n      return this._tail - this._head;\n    } else {\n      return this._capacityMask + 1 - (this._head - this._tail);\n    }\n  };\n\n  Queue.prototype.shift = function shift() {\n    var head = this._head;\n    if (head === this._tail) {\n      return undefined;\n    }\n\n    var x = this._list[head];\n    this._list[head] = undefined;\n    this._head = head + 1 & this._capacityMask;\n    if (head < HEAD_MAX_SHRINK && this._tail > TAIL_MIN_SHRINK && this._tail <= this._list.length >>> 2) {\n      this._shrinkArray();\n    }\n\n    return x;\n  };\n\n  Queue.prototype.isEmpty = function isEmpty() {\n    return this._head === this._tail;\n  };\n\n  Queue.prototype.length = function length() {\n    if (this._head === this._tail) {\n      return 0;\n    } else if (this._head < this._tail) {\n      return this._tail - this._head;\n    } else {\n      return this._capacityMask + 1 - (this._head - this._tail);\n    }\n  };\n\n  Queue.prototype._growArray = function _growArray() {\n    if (this._head) {\n      // copy existing data, head to end, then beginning to tail.\n      this._list = this._copyArray();\n      this._head = 0;\n    }\n\n    // head is at 0 and array is now full, safe to extend\n    this._tail = this._list.length;\n\n    this._list.length *= 2;\n    this._capacityMask = this._capacityMask << 1 | 1;\n  };\n\n  Queue.prototype._shrinkArray = function _shrinkArray() {\n    this._list.length >>>= 1;\n    this._capacityMask >>>= 1;\n  };\n\n  Queue.prototype._copyArray = function _copyArray() {\n    var newArray = [];\n    var list = this._list;\n    var len = list.length;\n\n    var i = void 0;\n    for (i = this._head; i < len; i++) {\n      newArray.push(list[i]);\n    }\n    for (i = 0; i < this._tail; i++) {\n      newArray.push(list[i]);\n    }\n\n    return newArray;\n  };\n\n  return Queue;\n}();\n\n/** @license MIT License (c) copyright 2010 original author or authors */\n\n/**\n * Combine two streams pairwise by index by applying f to values at corresponding\n * indices.  The returned stream ends when either of the input streams ends.\n * @param {function} f function to combine values\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nfunction zip$1(f, stream1, stream2) {\n  return zipArray$1(f, [stream1, stream2]);\n}\n\n/**\n* Combine streams pairwise (or tuple-wise) by index by applying f to values\n* at corresponding indices.  The returned stream ends when any of the input\n* streams ends.\n* @param {function} f function to combine values\n* @param {[Stream]} streams streams to zip using f\n* @returns {Stream} new stream with items at corresponding indices combined\n*  using f\n*/\nvar zipArray$1 = function zipArray(f, streams) {\n  return streams.length === 0 || containsCanonicalEmpty(streams) ? empty() : streams.length === 1 ? map$2(f, streams[0]) : new Zip(f, streams);\n};\n\nvar Zip = /*#__PURE__*/function () {\n  function Zip(f, sources) {\n    classCallCheck(this, Zip);\n\n    this.f = f;\n    this.sources = sources;\n  }\n\n  Zip.prototype.run = function run(sink, scheduler$$1) {\n    var l = this.sources.length;\n    var disposables = new Array(l);\n    var sinks = new Array(l);\n    var buffers = new Array(l);\n\n    var zipSink = new ZipSink(this.f, buffers, sinks, sink);\n\n    for (var indexSink, i = 0; i < l; ++i) {\n      buffers[i] = new Queue();\n      indexSink = sinks[i] = new IndexSink(i, zipSink);\n      disposables[i] = this.sources[i].run(indexSink, scheduler$$1);\n    }\n\n    return disposeAll(disposables);\n  };\n\n  return Zip;\n}();\n\nvar ZipSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ZipSink, _Pipe);\n\n  function ZipSink(f, buffers, sinks, sink) {\n    classCallCheck(this, ZipSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.f = f;\n    _this.sinks = sinks;\n    _this.buffers = buffers;\n    return _this;\n  }\n\n  ZipSink.prototype.event = function event(t, indexedValue) {\n    /* eslint complexity: [1, 5] */\n    if (!indexedValue.active) {\n      this._dispose(t, indexedValue.index);\n      return;\n    }\n\n    var buffers = this.buffers;\n    var buffer = buffers[indexedValue.index];\n\n    buffer.push(indexedValue.value);\n\n    if (buffer.length() === 1) {\n      if (!ready(this.buffers)) {\n        return;\n      }\n\n      emitZipped(this.f, t, buffers, this.sink);\n\n      if (ended(this.buffers, this.sinks)) {\n        this.sink.end(t);\n      }\n    }\n  };\n\n  ZipSink.prototype._dispose = function _dispose(t, index) {\n    var buffer = this.buffers[index];\n    if (buffer.isEmpty()) {\n      this.sink.end(t);\n    }\n  };\n\n  return ZipSink;\n}(Pipe);\n\nvar emitZipped = function emitZipped(f, t, buffers, sink) {\n  return sink.event(t, invoke(f, map(head, buffers)));\n};\n\nvar head = function head(buffer) {\n  return buffer.shift();\n};\n\nfunction ended(buffers, sinks) {\n  for (var i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty() && !sinks[i].active) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction ready(buffers) {\n  for (var i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty()) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @param {Stream} stream of streams on which to switch\n * @returns {Stream} switching stream\n */\nvar switchLatest = function switchLatest(stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Switch(stream);\n};\n\nvar Switch = /*#__PURE__*/function () {\n  function Switch(source) {\n    classCallCheck(this, Switch);\n\n    this.source = source;\n  }\n\n  Switch.prototype.run = function run(sink, scheduler$$1) {\n    var switchSink = new SwitchSink(sink, scheduler$$1);\n    return disposeBoth(switchSink, this.source.run(switchSink, scheduler$$1));\n  };\n\n  return Switch;\n}();\n\nvar SwitchSink = /*#__PURE__*/function () {\n  function SwitchSink(sink, scheduler$$1) {\n    classCallCheck(this, SwitchSink);\n\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.current = null;\n    this.ended = false;\n  }\n\n  SwitchSink.prototype.event = function event(t, stream) {\n    this._disposeCurrent(t);\n    this.current = new Segment(stream, t, Infinity, this, this.sink, this.scheduler);\n  };\n\n  SwitchSink.prototype.end = function end(t) {\n    this.ended = true;\n    this._checkEnd(t);\n  };\n\n  SwitchSink.prototype.error = function error(t, e) {\n    this.ended = true;\n    this.sink.error(t, e);\n  };\n\n  SwitchSink.prototype.dispose = function dispose() {\n    return this._disposeCurrent(currentTime(this.scheduler));\n  };\n\n  SwitchSink.prototype._disposeCurrent = function _disposeCurrent(t) {\n    if (this.current !== null) {\n      return this.current._dispose(t);\n    }\n  };\n\n  SwitchSink.prototype._disposeInner = function _disposeInner(t, inner) {\n    inner._dispose(t);\n    if (inner === this.current) {\n      this.current = null;\n    }\n  };\n\n  SwitchSink.prototype._checkEnd = function _checkEnd(t) {\n    if (this.ended && this.current === null) {\n      this.sink.end(t);\n    }\n  };\n\n  SwitchSink.prototype._endInner = function _endInner(t, inner) {\n    this._disposeInner(t, inner);\n    this._checkEnd(t);\n  };\n\n  SwitchSink.prototype._errorInner = function _errorInner(t, e, inner) {\n    this._disposeInner(t, inner);\n    this.sink.error(t, e);\n  };\n\n  return SwitchSink;\n}();\n\nvar Segment = /*#__PURE__*/function () {\n  function Segment(source, min, max, outer, sink, scheduler$$1) {\n    classCallCheck(this, Segment);\n\n    this.min = min;\n    this.max = max;\n    this.outer = outer;\n    this.sink = sink;\n    this.disposable = source.run(this, schedulerRelativeTo(min, scheduler$$1));\n  }\n\n  Segment.prototype.event = function event(t, x) {\n    var time = Math.max(0, t + this.min);\n    if (time < this.max) {\n      this.sink.event(time, x);\n    }\n  };\n\n  Segment.prototype.end = function end(t) {\n    this.outer._endInner(t + this.min, this);\n  };\n\n  Segment.prototype.error = function error(t, e) {\n    this.outer._errorInner(t + this.min, e, this);\n  };\n\n  Segment.prototype._dispose = function _dispose(t) {\n    tryDispose(t + this.min, this.disposable, this.sink);\n  };\n\n  return Segment;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Retain only items matching a predicate\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @param {Stream} stream stream to filter\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\nvar filter$1 = function filter(p, stream) {\n  return Filter.create(p, stream);\n};\n\n/**\n * Skip repeated events, using === to detect duplicates\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nvar skipRepeats = function skipRepeats(stream) {\n  return skipRepeatsWith$1(same, stream);\n};\n\n/**\n * Skip repeated events using the provided equals function to detect duplicates\n * @param {function(a:*, b:*):boolean} equals optional function to compare items\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nvar skipRepeatsWith$1 = function skipRepeatsWith(equals, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new SkipRepeats(equals, stream);\n};\n\nvar SkipRepeats = /*#__PURE__*/function () {\n  function SkipRepeats(equals, source) {\n    classCallCheck(this, SkipRepeats);\n\n    this.equals = equals;\n    this.source = source;\n  }\n\n  SkipRepeats.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler$$1);\n  };\n\n  return SkipRepeats;\n}();\n\nvar SkipRepeatsSink = /*#__PURE__*/function (_Pipe) {\n  inherits(SkipRepeatsSink, _Pipe);\n\n  function SkipRepeatsSink(equals, sink) {\n    classCallCheck(this, SkipRepeatsSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.equals = equals;\n    _this.value = void 0;\n    _this.init = true;\n    return _this;\n  }\n\n  SkipRepeatsSink.prototype.event = function event(t, x) {\n    if (this.init) {\n      this.init = false;\n      this.value = x;\n      this.sink.event(t, x);\n    } else if (!this.equals(this.value, x)) {\n      this.value = x;\n      this.sink.event(t, x);\n    }\n  };\n\n  return SkipRepeatsSink;\n}(Pipe);\n\nfunction same(a, b) {\n  return a === b;\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar until$1 = function until(signal, stream) {\n  return new Until(signal, stream);\n};\n\nvar since$1 = function since(signal, stream) {\n  return new Since(signal, stream);\n};\n\nvar during$1 = function during(timeWindow, stream) {\n  return until$1(join(timeWindow), since$1(timeWindow, stream));\n};\n\nvar Until = /*#__PURE__*/function () {\n  function Until(maxSignal, source) {\n    classCallCheck(this, Until);\n\n    this.maxSignal = maxSignal;\n    this.source = source;\n  }\n\n  Until.prototype.run = function run(sink, scheduler$$1) {\n    var min = new Bound(-Infinity, sink);\n    var max = new UpperBound(this.maxSignal, sink, scheduler$$1);\n    var disposable$$1 = this.source.run(new TimeWindowSink(min, max, sink), scheduler$$1);\n\n    return disposeAll([min, max, disposable$$1]);\n  };\n\n  return Until;\n}();\n\nvar Since = /*#__PURE__*/function () {\n  function Since(minSignal, source) {\n    classCallCheck(this, Since);\n\n    this.minSignal = minSignal;\n    this.source = source;\n  }\n\n  Since.prototype.run = function run(sink, scheduler$$1) {\n    var min = new LowerBound(this.minSignal, sink, scheduler$$1);\n    var max = new Bound(Infinity, sink);\n    var disposable$$1 = this.source.run(new TimeWindowSink(min, max, sink), scheduler$$1);\n\n    return disposeAll([min, max, disposable$$1]);\n  };\n\n  return Since;\n}();\n\nvar Bound = /*#__PURE__*/function (_Pipe) {\n  inherits(Bound, _Pipe);\n\n  function Bound(value, sink) {\n    classCallCheck(this, Bound);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.value = value;\n    return _this;\n  }\n\n  Bound.prototype.event = function event() {};\n\n  Bound.prototype.end = function end() {};\n\n  Bound.prototype.dispose = function dispose() {};\n\n  return Bound;\n}(Pipe);\n\nvar TimeWindowSink = /*#__PURE__*/function (_Pipe2) {\n  inherits(TimeWindowSink, _Pipe2);\n\n  function TimeWindowSink(min, max, sink) {\n    classCallCheck(this, TimeWindowSink);\n\n    var _this2 = possibleConstructorReturn(this, _Pipe2.call(this, sink));\n\n    _this2.min = min;\n    _this2.max = max;\n    return _this2;\n  }\n\n  TimeWindowSink.prototype.event = function event(t, x) {\n    if (t >= this.min.value && t < this.max.value) {\n      this.sink.event(t, x);\n    }\n  };\n\n  return TimeWindowSink;\n}(Pipe);\n\nvar LowerBound = /*#__PURE__*/function (_Pipe3) {\n  inherits(LowerBound, _Pipe3);\n\n  function LowerBound(signal, sink, scheduler$$1) {\n    classCallCheck(this, LowerBound);\n\n    var _this3 = possibleConstructorReturn(this, _Pipe3.call(this, sink));\n\n    _this3.value = Infinity;\n    _this3.disposable = signal.run(_this3, scheduler$$1);\n    return _this3;\n  }\n\n  LowerBound.prototype.event = function event(t /*, x */) {\n    if (t < this.value) {\n      this.value = t;\n    }\n  };\n\n  LowerBound.prototype.end = function end() {};\n\n  LowerBound.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return LowerBound;\n}(Pipe);\n\nvar UpperBound = /*#__PURE__*/function (_Pipe4) {\n  inherits(UpperBound, _Pipe4);\n\n  function UpperBound(signal, sink, scheduler$$1) {\n    classCallCheck(this, UpperBound);\n\n    var _this4 = possibleConstructorReturn(this, _Pipe4.call(this, sink));\n\n    _this4.value = Infinity;\n    _this4.disposable = signal.run(_this4, scheduler$$1);\n    return _this4;\n  }\n\n  UpperBound.prototype.event = function event(t, x) {\n    if (t < this.value) {\n      this.value = t;\n      this.sink.end(t);\n    }\n  };\n\n  UpperBound.prototype.end = function end() {};\n\n  UpperBound.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return UpperBound;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @param {Stream} stream\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\nvar delay$2 = function delay$$1(delayTime, stream) {\n  return delayTime <= 0 ? stream : new Delay(delayTime, stream);\n};\n\nvar Delay = /*#__PURE__*/function () {\n  function Delay(dt, source) {\n    classCallCheck(this, Delay);\n\n    this.dt = dt;\n    this.source = source;\n  }\n\n  Delay.prototype.run = function run(sink, scheduler$$1) {\n    var delaySink = new DelaySink(this.dt, sink, scheduler$$1);\n    return disposeBoth(delaySink, this.source.run(delaySink, scheduler$$1));\n  };\n\n  return Delay;\n}();\n\nvar DelaySink = /*#__PURE__*/function (_Pipe) {\n  inherits(DelaySink, _Pipe);\n\n  function DelaySink(dt, sink, scheduler$$1) {\n    classCallCheck(this, DelaySink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.dt = dt;\n    _this.scheduler = scheduler$$1;\n    return _this;\n  }\n\n  DelaySink.prototype.dispose = function dispose() {\n    var _this2 = this;\n\n    cancelAllTasks(function (_ref) {\n      var task = _ref.task;\n      return task.sink === _this2.sink;\n    }, this.scheduler);\n  };\n\n  DelaySink.prototype.event = function event(t, x) {\n    delay(this.dt, propagateEventTask$1(x, this.sink), this.scheduler);\n  };\n\n  DelaySink.prototype.end = function end(t) {\n    delay(this.dt, propagateEndTask(this.sink), this.scheduler);\n  };\n\n  return DelaySink;\n}(Pipe);\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\n/**\n * Limit the rate of events by suppressing events that occur too often\n * @param {Number} period time to suppress events\n * @param {Stream} stream\n * @returns {Stream}\n */\nvar throttle$1 = function throttle(period, stream) {\n  return isCanonicalEmpty(stream) ? empty() : stream instanceof Map ? commuteMapThrottle(period, stream) : stream instanceof Throttle ? fuseThrottle(period, stream) : new Throttle(period, stream);\n};\n\nvar commuteMapThrottle = function commuteMapThrottle(period, mapStream) {\n  return Map.create(mapStream.f, throttle$1(period, mapStream.source));\n};\n\nvar fuseThrottle = function fuseThrottle(period, throttleStream) {\n  return new Throttle(Math.max(period, throttleStream.period), throttleStream.source);\n};\n\nvar Throttle = /*#__PURE__*/function () {\n  function Throttle(period, source) {\n    classCallCheck(this, Throttle);\n\n    this.period = period;\n    this.source = source;\n  }\n\n  Throttle.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new ThrottleSink(this.period, sink), scheduler$$1);\n  };\n\n  return Throttle;\n}();\n\nvar ThrottleSink = /*#__PURE__*/function (_Pipe) {\n  inherits(ThrottleSink, _Pipe);\n\n  function ThrottleSink(period, sink) {\n    classCallCheck(this, ThrottleSink);\n\n    var _this = possibleConstructorReturn(this, _Pipe.call(this, sink));\n\n    _this.time = 0;\n    _this.period = period;\n    return _this;\n  }\n\n  ThrottleSink.prototype.event = function event(t, x) {\n    if (t >= this.time) {\n      this.time = t + this.period;\n      this.sink.event(t, x);\n    }\n  };\n\n  return ThrottleSink;\n}(Pipe);\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * @param {Number} period events occuring more frequently than this\n *  will be suppressed\n * @param {Stream} stream stream to debounce\n * @returns {Stream} new debounced stream\n */\n\n\nvar debounce$1 = function debounce(period, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Debounce(period, stream);\n};\n\nvar Debounce = /*#__PURE__*/function () {\n  function Debounce(dt, source) {\n    classCallCheck(this, Debounce);\n\n    this.dt = dt;\n    this.source = source;\n  }\n\n  Debounce.prototype.run = function run(sink, scheduler$$1) {\n    return new DebounceSink(this.dt, this.source, sink, scheduler$$1);\n  };\n\n  return Debounce;\n}();\n\nvar DebounceSink = /*#__PURE__*/function () {\n  function DebounceSink(dt, source, sink, scheduler$$1) {\n    classCallCheck(this, DebounceSink);\n\n    this.dt = dt;\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.value = void 0;\n    this.timer = null;\n\n    this.disposable = source.run(this, scheduler$$1);\n  }\n\n  DebounceSink.prototype.event = function event(t, x) {\n    this._clearTimer();\n    this.value = x;\n    this.timer = delay(this.dt, new DebounceTask(this, x), this.scheduler);\n  };\n\n  DebounceSink.prototype._event = function _event(t, x) {\n    this._clearTimer();\n    this.sink.event(t, x);\n  };\n\n  DebounceSink.prototype.end = function end(t) {\n    if (this._clearTimer()) {\n      this.sink.event(t, this.value);\n      this.value = undefined;\n    }\n    this.sink.end(t);\n  };\n\n  DebounceSink.prototype.error = function error(t, x) {\n    this._clearTimer();\n    this.sink.error(t, x);\n  };\n\n  DebounceSink.prototype.dispose = function dispose() {\n    this._clearTimer();\n    this.disposable.dispose();\n  };\n\n  DebounceSink.prototype._clearTimer = function _clearTimer() {\n    if (this.timer === null) {\n      return false;\n    }\n    this.timer.dispose();\n    this.timer = null;\n    return true;\n  };\n\n  return DebounceSink;\n}();\n\nvar DebounceTask = /*#__PURE__*/function () {\n  function DebounceTask(debounce, value) {\n    classCallCheck(this, DebounceTask);\n\n    this.debounce = debounce;\n    this.value = value;\n  }\n\n  DebounceTask.prototype.run = function run(t) {\n    this.debounce._event(t, this.value);\n  };\n\n  DebounceTask.prototype.error = function error(t, e) {\n    this.debounce.error(t, e);\n  };\n\n  DebounceTask.prototype.dispose = function dispose() {};\n\n  return DebounceTask;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.\n * Event order is preserved. The stream will fail if any promise rejects.\n */\nvar awaitPromises = function awaitPromises(stream) {\n  return isCanonicalEmpty(stream) ? empty() : new Await(stream);\n};\n\n/**\n * Create a stream containing only the promise's fulfillment\n * value at the time it fulfills.\n * @param {Promise<T>} p promise\n * @return {Stream<T>} stream containing promise's fulfillment value.\n *  If the promise rejects, the stream will error\n */\nvar fromPromise = /*#__PURE__*/compose(awaitPromises, now);\n\nvar Await = /*#__PURE__*/function () {\n  function Await(source) {\n    classCallCheck(this, Await);\n\n    this.source = source;\n  }\n\n  Await.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(new AwaitSink(sink, scheduler$$1), scheduler$$1);\n  };\n\n  return Await;\n}();\n\nvar AwaitSink = /*#__PURE__*/function () {\n  function AwaitSink(sink, scheduler$$1) {\n    var _this = this;\n\n    classCallCheck(this, AwaitSink);\n\n    this.sink = sink;\n    this.scheduler = scheduler$$1;\n    this.queue = Promise.resolve();\n\n    // Pre-create closures, to avoid creating them per event\n    this._eventBound = function (x) {\n      return _this.sink.event(currentTime(_this.scheduler), x);\n    };\n    this._endBound = function () {\n      return _this.sink.end(currentTime(_this.scheduler));\n    };\n    this._errorBound = function (e) {\n      return _this.sink.error(currentTime(_this.scheduler), e);\n    };\n  }\n\n  AwaitSink.prototype.event = function event(t, promise) {\n    var _this2 = this;\n\n    this.queue = this.queue.then(function () {\n      return _this2._event(promise);\n    }).catch(this._errorBound);\n  };\n\n  AwaitSink.prototype.end = function end(t) {\n    this.queue = this.queue.then(this._endBound).catch(this._errorBound);\n  };\n\n  AwaitSink.prototype.error = function error(t, e) {\n    var _this3 = this;\n\n    // Don't resolve error values, propagate directly\n    this.queue = this.queue.then(function () {\n      return _this3._errorBound(e);\n    }).catch(fatalError);\n  };\n\n  AwaitSink.prototype._event = function _event(promise) {\n    return promise.then(this._eventBound);\n  };\n\n  return AwaitSink;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar SafeSink = /*#__PURE__*/function () {\n  function SafeSink(sink) {\n    classCallCheck(this, SafeSink);\n\n    this.sink = sink;\n    this.active = true;\n  }\n\n  SafeSink.prototype.event = function event(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.sink.event(t, x);\n  };\n\n  SafeSink.prototype.end = function end(t, x) {\n    if (!this.active) {\n      return;\n    }\n    this.disable();\n    this.sink.end(t, x);\n  };\n\n  SafeSink.prototype.error = function error(t, e) {\n    this.disable();\n    this.sink.error(t, e);\n  };\n\n  SafeSink.prototype.disable = function disable() {\n    this.active = false;\n    return this.sink;\n  };\n\n  return SafeSink;\n}();\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction tryEvent(t, x, sink) {\n  try {\n    sink.event(t, x);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}\n\nfunction tryEnd(t, sink) {\n  try {\n    sink.end(t);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * If stream encounters an error, recover and continue with items from stream\n * returned by f.\n * @param {function(error:*):Stream} f function which returns a new stream\n * @param {Stream} stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\nvar recoverWith$1 = function recoverWith(f, stream) {\n  return isCanonicalEmpty(stream) ? empty() : new RecoverWith(f, stream);\n};\n\n/**\n * Create a stream containing only an error\n * @param {*} e error value, preferably an Error or Error subtype\n * @returns {Stream} new stream containing only an error\n */\nvar throwError = function throwError(e) {\n  return new ErrorStream(e);\n};\n\nvar ErrorStream = /*#__PURE__*/function () {\n  function ErrorStream(e) {\n    classCallCheck(this, ErrorStream);\n\n    this.value = e;\n  }\n\n  ErrorStream.prototype.run = function run(sink, scheduler$$1) {\n    return asap(propagateErrorTask$1(this.value, sink), scheduler$$1);\n  };\n\n  return ErrorStream;\n}();\n\nvar RecoverWith = /*#__PURE__*/function () {\n  function RecoverWith(f, source) {\n    classCallCheck(this, RecoverWith);\n\n    this.f = f;\n    this.source = source;\n  }\n\n  RecoverWith.prototype.run = function run(sink, scheduler$$1) {\n    return new RecoverWithSink(this.f, this.source, sink, scheduler$$1);\n  };\n\n  return RecoverWith;\n}();\n\nvar RecoverWithSink = /*#__PURE__*/function () {\n  function RecoverWithSink(f, source, sink, scheduler$$1) {\n    classCallCheck(this, RecoverWithSink);\n\n    this.f = f;\n    this.sink = new SafeSink(sink);\n    this.scheduler = scheduler$$1;\n    this.disposable = source.run(this, scheduler$$1);\n  }\n\n  RecoverWithSink.prototype.event = function event(t, x) {\n    tryEvent(t, x, this.sink);\n  };\n\n  RecoverWithSink.prototype.end = function end(t) {\n    tryEnd(t, this.sink);\n  };\n\n  RecoverWithSink.prototype.error = function error(t, e) {\n    var nextSink = this.sink.disable();\n\n    tryDispose(t, this.disposable, this.sink);\n\n    this._startNext(t, e, nextSink);\n  };\n\n  RecoverWithSink.prototype._startNext = function _startNext(t, x, sink) {\n    try {\n      this.disposable = this._continue(this.f, t, x, sink);\n    } catch (e) {\n      sink.error(t, e);\n    }\n  };\n\n  RecoverWithSink.prototype._continue = function _continue(f, t, x, sink) {\n    return run$1(sink, this.scheduler, withLocalTime$1(t, f(x)));\n  };\n\n  RecoverWithSink.prototype.dispose = function dispose() {\n    return this.disposable.dispose();\n  };\n\n  return RecoverWithSink;\n}();\n\nvar multicast = function multicast(stream) {\n  return stream instanceof Multicast || isCanonicalEmpty(stream) ? stream : new Multicast(stream);\n};\n\nvar Multicast = /*#__PURE__*/function () {\n  function Multicast(source) {\n    classCallCheck(this, Multicast);\n\n    this.source = new MulticastSource(source);\n  }\n\n  Multicast.prototype.run = function run(sink, scheduler$$1) {\n    return this.source.run(sink, scheduler$$1);\n  };\n\n  return Multicast;\n}();\n\nvar MulticastSource = /*#__PURE__*/function () {\n  function MulticastSource(source) {\n    classCallCheck(this, MulticastSource);\n\n    this.source = source;\n    this.sinks = [];\n    this.disposable = disposeNone();\n  }\n\n  MulticastSource.prototype.run = function run(sink, scheduler$$1) {\n    var n = this.add(sink);\n    if (n === 1) {\n      this.disposable = this.source.run(this, scheduler$$1);\n    }\n    return disposeOnce(new MulticastDisposable(this, sink));\n  };\n\n  MulticastSource.prototype.dispose = function dispose() {\n    var disposable$$1 = this.disposable;\n    this.disposable = disposeNone();\n    return disposable$$1.dispose();\n  };\n\n  MulticastSource.prototype.add = function add(sink) {\n    this.sinks = append(sink, this.sinks);\n    return this.sinks.length;\n  };\n\n  MulticastSource.prototype.remove = function remove$$1(sink) {\n    var i = findIndex(sink, this.sinks);\n    // istanbul ignore next\n    if (i >= 0) {\n      this.sinks = remove(i, this.sinks);\n    }\n\n    return this.sinks.length;\n  };\n\n  MulticastSource.prototype.event = function event(time, value) {\n    var s = this.sinks;\n    if (s.length === 1) {\n      return s[0].event(time, value);\n    }\n    for (var i = 0; i < s.length; ++i) {\n      tryEvent(time, value, s[i]);\n    }\n  };\n\n  MulticastSource.prototype.end = function end(time) {\n    var s = this.sinks;\n    for (var i = 0; i < s.length; ++i) {\n      tryEnd(time, s[i]);\n    }\n  };\n\n  MulticastSource.prototype.error = function error(time, err) {\n    var s = this.sinks;\n    for (var i = 0; i < s.length; ++i) {\n      s[i].error(time, err);\n    }\n  };\n\n  return MulticastSource;\n}();\n\nvar MulticastDisposable = /*#__PURE__*/function () {\n  function MulticastDisposable(source, sink) {\n    classCallCheck(this, MulticastDisposable);\n\n    this.source = source;\n    this.sink = sink;\n  }\n\n  MulticastDisposable.prototype.dispose = function dispose() {\n    if (this.source.remove(this.sink) === 0) {\n      this.source.dispose();\n    }\n  };\n\n  return MulticastDisposable;\n}();\n\n/** @license MIT License (c) copyright 2016 original author or authors */\n/* eslint-disable import/first */\nvar zipItems$$1 = /*#__PURE__*/curry3(zipItems$1);\nvar withItems$$1 = /*#__PURE__*/curry2(withItems$1);\n\n// -----------------------------------------------------------------------\n// Observing\n\nvar runEffects$$1 = /*#__PURE__*/curry2(runEffects$1);\nvar run$$1 = /*#__PURE__*/curry3(run$1);\n\n// -------------------------------------------------------\n\nvar withLocalTime$$1 = /*#__PURE__*/curry2(withLocalTime$1);\n\n// -------------------------------------------------------\n\nvar loop$$1 = /*#__PURE__*/curry3(loop$1);\n\n// -------------------------------------------------------\n\nvar scan$$1 = /*#__PURE__*/curry3(scan$1);\n\n// -----------------------------------------------------------------------\n// Extending\n\nvar startWith$$1 = /*#__PURE__*/curry2(startWith$1);\n\n// -----------------------------------------------------------------------\n// Transforming\n\nvar map$1 = /*#__PURE__*/curry2(map$2);\nvar constant$$1 = /*#__PURE__*/curry2(constant$1);\nvar tap$$1 = /*#__PURE__*/curry2(tap$1);\nvar ap$$1 = /*#__PURE__*/curry2(ap$1);\n\n// -----------------------------------------------------------------------\n// FlatMapping\n\nvar chain$$1 = /*#__PURE__*/curry2(chain$1);\nvar continueWith$$1 = /*#__PURE__*/curry2(continueWith$1);\n\nvar concatMap$$1 = /*#__PURE__*/curry2(concatMap$1);\n\n// -----------------------------------------------------------------------\n// Concurrent merging\n\nvar mergeConcurrently$$1 = /*#__PURE__*/curry2(mergeConcurrently$1);\nvar mergeMapConcurrently$$1 = /*#__PURE__*/curry3(mergeMapConcurrently$1);\n\n// -----------------------------------------------------------------------\n// Merging\n\nvar merge$$1 = /*#__PURE__*/curry2(merge$1);\n// -----------------------------------------------------------------------\n// Combining\n\nvar combine$$1 = /*#__PURE__*/curry3(combine$1);\nvar combineArray$$1 = /*#__PURE__*/curry2(combineArray$1);\n\n// -----------------------------------------------------------------------\n// Sampling\n\nvar sample$$1 = /*#__PURE__*/curry2(sample$1);\nvar snapshot$$1 = /*#__PURE__*/curry3(snapshot$1);\n\n// -----------------------------------------------------------------------\n// Zipping\n\nvar zip$$1 = /*#__PURE__*/curry3(zip$1);\nvar zipArray$$1 = /*#__PURE__*/curry2(zipArray$1);\n\n// -----------------------------------------------------------------------\n// Filtering\n\nvar filter$$1 = /*#__PURE__*/curry2(filter$1);\nvar skipRepeatsWith$$1 = /*#__PURE__*/curry2(skipRepeatsWith$1);\n\n// -----------------------------------------------------------------------\n// Slicing\n\nvar take$$1 = /*#__PURE__*/curry2(take$1);\nvar skip$$1 = /*#__PURE__*/curry2(skip$1);\nvar slice$$1 = /*#__PURE__*/curry3(slice$1);\nvar takeWhile$$1 = /*#__PURE__*/curry2(takeWhile$1);\nvar skipWhile$$1 = /*#__PURE__*/curry2(skipWhile$1);\nvar skipAfter$$1 = /*#__PURE__*/curry2(skipAfter$1);\n\n// -----------------------------------------------------------------------\n// Time slicing\n\nvar until$$1 = /*#__PURE__*/curry2(until$1);\nvar since$$1 = /*#__PURE__*/curry2(since$1);\nvar during$$1 = /*#__PURE__*/curry2(during$1);\n\n// -----------------------------------------------------------------------\n// Delaying\n\nvar delay$1 = /*#__PURE__*/curry2(delay$2);\n\n// -----------------------------------------------------------------------\n// Rate limiting\n\nvar throttle$$1 = /*#__PURE__*/curry2(throttle$1);\nvar debounce$$1 = /*#__PURE__*/curry2(debounce$1);\n\n// -----------------------------------------------------------------------\n// Error handling\n\nvar recoverWith$$1 = /*#__PURE__*/curry2(recoverWith$1);\n// ----------------------------------------------------------------------\nvar propagateTask$$1 = /*#__PURE__*/curry3(propagateTask$1);\nvar propagateEventTask$$1 = /*#__PURE__*/curry2(propagateEventTask$1);\nvar propagateErrorTask$$1 = /*#__PURE__*/curry2(propagateErrorTask$1);\n\nexport { zipItems$$1 as zipItems, withItems$$1 as withItems, runEffects$$1 as runEffects, run$$1 as run, withLocalTime$$1 as withLocalTime, loop$$1 as loop, scan$$1 as scan, startWith$$1 as startWith, map$1 as map, constant$$1 as constant, tap$$1 as tap, ap$$1 as ap, chain$$1 as chain, join, continueWith$$1 as continueWith, concatMap$$1 as concatMap, mergeConcurrently$$1 as mergeConcurrently, mergeMapConcurrently$$1 as mergeMapConcurrently, merge$$1 as merge, mergeArray, combine$$1 as combine, combineArray$$1 as combineArray, sample$$1 as sample, snapshot$$1 as snapshot, zip$$1 as zip, zipArray$$1 as zipArray, filter$$1 as filter, skipRepeats, skipRepeatsWith$$1 as skipRepeatsWith, take$$1 as take, skip$$1 as skip, slice$$1 as slice, takeWhile$$1 as takeWhile, skipWhile$$1 as skipWhile, skipAfter$$1 as skipAfter, until$$1 as until, since$$1 as since, during$$1 as during, delay$1 as delay, throttle$$1 as throttle, debounce$$1 as debounce, recoverWith$$1 as recoverWith, throwError, propagateTask$$1 as propagateTask, propagateEventTask$$1 as propagateEventTask, propagateErrorTask$$1 as propagateErrorTask, propagateEndTask, empty, never, now, at, periodic$1 as periodic, newStream, switchLatest, fromPromise, awaitPromises, multicast, MulticastSource };\n//# sourceMappingURL=index.es.js.map\n","import '@most/types';\nimport { map, merge, scan } from '@most/core';\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\n// id :: a -> a\nvar id = function id(x) {\n  return x;\n};\n\n// curry2 :: ((a, b) -> c) -> (a -> b -> c)\nfunction curry2(f) {\n  function curried(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return curried;\n      case 1:\n        return function (b) {\n          return f(a, b);\n        };\n      default:\n        return f(a, b);\n    }\n  }\n  return curried;\n}\n\n// curry3 :: ((a, b, c) -> d) -> (a -> b -> c -> d)\nfunction curry3(f) {\n  function curried(a, b, c) {\n    // eslint-disable-line complexity\n    switch (arguments.length) {\n      case 0:\n        return curried;\n      case 1:\n        return curry2(function (b, c) {\n          return f(a, b, c);\n        });\n      case 2:\n        return function (c) {\n          return f(a, b, c);\n        };\n      default:\n        return f(a, b, c);\n    }\n  }\n  return curried;\n}\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar Right = function Right(value) {\n  return { right: true, value: value };\n};\n\nvar Left = function Left(value) {\n  return { right: false, value: value };\n};\n\nvar classify = function classify(p, a) {\n  return p(a) ? Right(a) : Left(a);\n};\n\nvar bimapEither = function bimapEither(f, g, e) {\n  return e.right ? Right(g(e.value)) : Left(f(e.value));\n};\n\nvar toPair = function toPair(_ref, eab) {\n  var _ref2 = slicedToArray(_ref, 2),\n      a = _ref2[0],\n      b = _ref2[1];\n\n  return eab.right ? [a, eab.value] : [eab.value, b];\n};\n\n// Streams of coproducts\n\nvar inject = curry2(function (sa, sb) {\n  return merge(map(Left, sa), map(Right, sb));\n});\n\nvar partition = curry2(function (p, sa) {\n  return map(function (a) {\n    return classify(p, a);\n  }, sa);\n});\n\nvar unpartition = function unpartition(saa) {\n  return map(function (aa) {\n    return aa.value;\n  }, saa);\n};\n\nvar _mapEither = function _mapEither(f, g, s) {\n  return map(function (eab) {\n    return bimapEither(f, g, eab);\n  }, s);\n};\n\nvar mapEither = curry3(function (f, g, s) {\n  return _mapEither(f, g, s);\n});\n\nvar mapLeft = curry2(function (f, s) {\n  return _mapEither(f, id, s);\n});\n\nvar mapRight = curry2(function (g, s) {\n  return _mapEither(id, g, s);\n});\n\nvar dup = function dup(a) {\n  return [a, a];\n};\n\nvar projectPair = function projectPair(f, g, a) {\n  return [f(a), g(a)];\n};\n\nvar bimapPair = function bimapPair(f, g, _ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      a = _ref2[0],\n      b = _ref2[1];\n\n  return [f(a), g(b)];\n};\n\nvar foldPair = function foldPair(f, _ref3) {\n  var _ref4 = slicedToArray(_ref3, 2),\n      a = _ref4[0],\n      b = _ref4[1];\n\n  return f(a, b);\n};\n\n// Streams of products\n\nvar project = curry3(function (f, g, s) {\n  return map(function (a) {\n    return projectPair(f, g, a);\n  }, s);\n});\n\nvar split = function split(s) {\n  return map(dup, s);\n};\n\nvar unsplit = curry2(function (f, s) {\n  return map(function (p) {\n    return foldPair(f, p);\n  }, s);\n});\n\nvar _mapBoth = function _mapBoth(f, g, s) {\n  return map(function (p) {\n    return bimapPair(f, g, p);\n  }, s);\n};\n\nvar mapBoth = curry3(function (f, g, s) {\n  return _mapBoth(f, g, s);\n});\n\nvar mapFirst = curry2(function (f, s) {\n  return _mapBoth(f, id, s);\n});\n\nvar mapSecond = curry2(function (g, s) {\n  return _mapBoth(id, g, s);\n});\n\nvar update = curry2(function (ab, s) {\n  return scan(toPair, ab, s);\n});\n\nexport { inject, partition, unpartition, mapEither, mapLeft, mapRight, project, split, unsplit, _mapBoth, mapBoth, mapFirst, mapSecond, update, Right, Left, classify, bimapEither, toPair, dup, projectPair, bimapPair, foldPair };\n//# sourceMappingURL=index.es.js.map\n","/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar empty = {};\n\n/**\n * Mix the properties from the source object into the destination object.\n * When the same property occurs in more then one object, the right most\n * value wins.\n *\n * @param {Object} dest the object to copy properties to\n * @param {Object} sources the objects to copy properties from.  May be 1 to N arguments, but not an Array.\n * @return {Object} the destination object\n */\nfunction mixin(dest /*, sources... */) {\n\tvar i, l, source, name;\n\n\tif (!dest) { dest = {}; }\n\tfor (i = 1, l = arguments.length; i < l; i += 1) {\n\t\tsource = arguments[i];\n\t\tfor (name in source) {\n\t\t\tif (!(name in dest) || (dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name]))) {\n\t\t\t\tdest[name] = source[name];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dest; // Object\n}\n\nmodule.exports = mixin;\n","/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar encodedSpaceRE, urlEncodedSpaceRE;\n\nencodedSpaceRE = /%20/g;\nurlEncodedSpaceRE = /\\+/g;\n\nfunction urlEncode(str) {\n\tstr = encodeURIComponent(str);\n\t// spec says space should be encoded as '+'\n\treturn str.replace(encodedSpaceRE, '+');\n}\n\nfunction urlDecode(str) {\n\t// spec says space should be encoded as '+'\n\tstr = str.replace(urlEncodedSpaceRE, ' ');\n\treturn decodeURIComponent(str);\n}\n\nfunction append(str, name, value) {\n\tif (Array.isArray(value)) {\n\t\tvalue.forEach(function (value) {\n\t\t\tstr = append(str, name, value);\n\t\t});\n\t}\n\telse {\n\t\tif (str.length > 0) {\n\t\t\tstr += '&';\n\t\t}\n\t\tstr += urlEncode(name);\n\t\tif (value !== undefined && value !== null) {\n\t\t\tstr += '=' + urlEncode(value);\n\t\t}\n\t}\n\treturn str;\n}\n\nmodule.exports = {\n\n\tread: function (str) {\n\t\tvar obj = {};\n\t\tstr.split('&').forEach(function (entry) {\n\t\t\tvar pair, name, value;\n\t\t\tpair = entry.split('=');\n\t\t\tname = urlDecode(pair[0]);\n\t\t\tif (pair.length === 2) {\n\t\t\t\tvalue = urlDecode(pair[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = null;\n\t\t\t}\n\t\t\tif (name in obj) {\n\t\t\t\tif (!Array.isArray(obj[name])) {\n\t\t\t\t\t// convert to an array, perserving currnent value\n\t\t\t\t\tobj[name] = [obj[name]];\n\t\t\t\t}\n\t\t\t\tobj[name].push(value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj[name] = value;\n\t\t\t}\n\t\t});\n\t\treturn obj;\n\t},\n\n\twrite: function (obj) {\n\t\tvar str = '';\n\t\tObject.keys(obj).forEach(function (name) {\n\t\t\tstr = append(str, name, obj[name]);\n\t\t});\n\t\treturn str;\n\t}\n\n};\n","/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar mixin, xWWWFormURLEncoder, origin, urlRE, absoluteUrlRE, fullyQualifiedUrlRE;\n\nmixin = require('./util/mixin');\nxWWWFormURLEncoder = require('./mime/type/application/x-www-form-urlencoded');\n\nurlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?(\\/[^?#]*)?(\\?[^#]*)?(#\\S*)?/i;\nabsoluteUrlRE = /^([a-z][a-z0-9\\-\\+\\.]*:\\/\\/|\\/)/i;\nfullyQualifiedUrlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?\\//i;\n\n/**\n * Apply params to the template to create a URL.\n *\n * Parameters that are not applied directly to the template, are appended\n * to the URL as query string parameters.\n *\n * @param {string} template the URI template\n * @param {Object} params parameters to apply to the template\n * @return {string} the resulting URL\n */\nfunction buildUrl(template, params) {\n\t// internal builder to convert template with params.\n\tvar url, name, queryStringParams, queryString, re;\n\n\turl = template;\n\tqueryStringParams = {};\n\n\tif (params) {\n\t\tfor (name in params) {\n\t\t\t/*jshint forin:false */\n\t\t\tre = new RegExp('\\\\{' + name + '\\\\}');\n\t\t\tif (re.test(url)) {\n\t\t\t\turl = url.replace(re, encodeURIComponent(params[name]), 'g');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueryStringParams[name] = params[name];\n\t\t\t}\n\t\t}\n\n\t\tqueryString = xWWWFormURLEncoder.write(queryStringParams);\n\t\tif (queryString) {\n\t\t\turl += url.indexOf('?') === -1 ? '?' : '&';\n\t\t\turl += queryString;\n\t\t}\n\t}\n\treturn url;\n}\n\nfunction startsWith(str, test) {\n\treturn str.indexOf(test) === 0;\n}\n\n/**\n * Create a new URL Builder\n *\n * @param {string|UrlBuilder} template the base template to build from, may be another UrlBuilder\n * @param {Object} [params] base parameters\n * @constructor\n */\nfunction UrlBuilder(template, params) {\n\tif (!(this instanceof UrlBuilder)) {\n\t\t// invoke as a constructor\n\t\treturn new UrlBuilder(template, params);\n\t}\n\n\tif (template instanceof UrlBuilder) {\n\t\tthis._template = template.template;\n\t\tthis._params = mixin({}, this._params, params);\n\t}\n\telse {\n\t\tthis._template = (template || '').toString();\n\t\tthis._params = params || {};\n\t}\n}\n\nUrlBuilder.prototype = {\n\n\t/**\n\t * Create a new UrlBuilder instance that extends the current builder.\n\t * The current builder is unmodified.\n\t *\n\t * @param {string} [template] URL template to append to the current template\n\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t * @return {UrlBuilder} the new builder\n\t */\n\tappend: function (template,  params) {\n\t\t// TODO consider query strings and fragments\n\t\treturn new UrlBuilder(this._template + template, mixin({}, this._params, params));\n\t},\n\n\t/**\n\t * Create a new UrlBuilder with a fully qualified URL based on the\n\t * window's location or base href and the current templates relative URL.\n\t *\n\t * Path variables are preserved.\n\t *\n\t * *Browser only*\n\t *\n\t * @return {UrlBuilder} the fully qualified URL template\n\t */\n\tfullyQualify: function () {\n\t\tif (typeof location === 'undefined') { return this; }\n\t\tif (this.isFullyQualified()) { return this; }\n\n\t\tvar template = this._template;\n\n\t\tif (startsWith(template, '//')) {\n\t\t\ttemplate = origin.protocol + template;\n\t\t}\n\t\telse if (startsWith(template, '/')) {\n\t\t\ttemplate = origin.origin + template;\n\t\t}\n\t\telse if (!this.isAbsolute()) {\n\t\t\ttemplate = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf('/') + 1);\n\t\t}\n\n\t\tif (template.indexOf('/', 8) === -1) {\n\t\t\t// default the pathname to '/'\n\t\t\ttemplate = template + '/';\n\t\t}\n\n\t\treturn new UrlBuilder(template, this._params);\n\t},\n\n\t/**\n\t * True if the URL is absolute\n\t *\n\t * @return {boolean}\n\t */\n\tisAbsolute: function () {\n\t\treturn absoluteUrlRE.test(this.build());\n\t},\n\n\t/**\n\t * True if the URL is fully qualified\n\t *\n\t * @return {boolean}\n\t */\n\tisFullyQualified: function () {\n\t\treturn fullyQualifiedUrlRE.test(this.build());\n\t},\n\n\t/**\n\t * True if the URL is cross origin. The protocol, host and port must not be\n\t * the same in order to be cross origin,\n\t *\n\t * @return {boolean}\n\t */\n\tisCrossOrigin: function () {\n\t\tif (!origin) {\n\t\t\treturn true;\n\t\t}\n\t\tvar url = this.parts();\n\t\treturn url.protocol !== origin.protocol ||\n\t\t       url.hostname !== origin.hostname ||\n\t\t       url.port !== origin.port;\n\t},\n\n\t/**\n\t * Split a URL into its consituent parts following the naming convention of\n\t * 'window.location'. One difference is that the port will contain the\n\t * protocol default if not specified.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/DOM/window.location\n\t *\n\t * @returns {Object} a 'window.location'-like object\n\t */\n\tparts: function () {\n\t\t/*jshint maxcomplexity:20 */\n\t\tvar url, parts;\n\t\turl = this.fullyQualify().build().match(urlRE);\n\t\tparts = {\n\t\t\thref: url[0],\n\t\t\tprotocol: url[1],\n\t\t\thost: url[3] || '',\n\t\t\thostname: url[4] || '',\n\t\t\tport: url[6],\n\t\t\tpathname: url[7] || '',\n\t\t\tsearch: url[8] || '',\n\t\t\thash: url[9] || ''\n\t\t};\n\t\tparts.origin = parts.protocol + '//' + parts.host;\n\t\tparts.port = parts.port || (parts.protocol === 'https:' ? '443' : parts.protocol === 'http:' ? '80' : '');\n\t\treturn parts;\n\t},\n\n\t/**\n\t * Expand the template replacing path variables with parameters\n\t *\n\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t * @return {string} the expanded URL\n\t */\n\tbuild: function (params) {\n\t\treturn buildUrl(this._template, mixin({}, this._params, params));\n\t},\n\n\t/**\n\t * @see build\n\t */\n\ttoString: function () {\n\t\treturn this.build();\n\t}\n\n};\n\norigin = typeof location !== 'undefined' ? new UrlBuilder(location.href).parts() : void 0;\n\nmodule.exports = UrlBuilder;\n","/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\n/**\n * Normalize HTTP header names using the pseudo camel case.\n *\n * For example:\n *   content-type         -> Content-Type\n *   accepts              -> Accepts\n *   x-custom-header-name -> X-Custom-Header-Name\n *\n * @param {string} name the raw header name\n * @return {string} the normalized header name\n */\nfunction normalizeHeaderName(name) {\n\treturn name.toLowerCase()\n\t\t.split('-')\n\t\t.map(function (chunk) { return chunk.charAt(0).toUpperCase() + chunk.slice(1); })\n\t\t.join('-');\n}\n\nmodule.exports = normalizeHeaderName;\n","/*\n * Copyright 2014-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\n/*jshint latedef: nofunc */\n\nvar normalizeHeaderName = require('./normalizeHeaderName');\n\nfunction property(promise, name) {\n\treturn promise.then(\n\t\tfunction (value) {\n\t\t\treturn value && value[name];\n\t\t},\n\t\tfunction (value) {\n\t\t\treturn Promise.reject(value && value[name]);\n\t\t}\n\t);\n}\n\n/**\n * Obtain the response entity\n *\n * @returns {Promise} for the response entity\n */\nfunction entity() {\n\t/*jshint validthis:true */\n\treturn property(this, 'entity');\n}\n\n/**\n * Obtain the response status\n *\n * @returns {Promise} for the response status\n */\nfunction status() {\n\t/*jshint validthis:true */\n\treturn property(property(this, 'status'), 'code');\n}\n\n/**\n * Obtain the response headers map\n *\n * @returns {Promise} for the response headers map\n */\nfunction headers() {\n\t/*jshint validthis:true */\n\treturn property(this, 'headers');\n}\n\n/**\n * Obtain a specific response header\n *\n * @param {String} headerName the header to retrieve\n * @returns {Promise} for the response header's value\n */\nfunction header(headerName) {\n\t/*jshint validthis:true */\n\theaderName = normalizeHeaderName(headerName);\n\treturn property(this.headers(), headerName);\n}\n\n/**\n * Follow a related resource\n *\n * The relationship to follow may be define as a plain string, an object\n * with the rel and params, or an array containing one or more entries\n * with the previous forms.\n *\n * Examples:\n *   response.follow('next')\n *\n *   response.follow({ rel: 'next', params: { pageSize: 100 } })\n *\n *   response.follow([\n *       { rel: 'items', params: { projection: 'noImages' } },\n *       'search',\n *       { rel: 'findByGalleryIsNull', params: { projection: 'noImages' } },\n *       'items'\n *   ])\n *\n * @param {String|Object|Array} rels one, or more, relationships to follow\n * @returns ResponsePromise<Response> related resource\n */\nfunction follow(rels) {\n\t/*jshint validthis:true */\n\trels = [].concat(rels);\n\n\treturn make(rels.reduce(function (response, rel) {\n\t\treturn response.then(function (response) {\n\t\t\tif (typeof rel === 'string') {\n\t\t\t\trel = { rel: rel };\n\t\t\t}\n\t\t\tif (typeof response.entity.clientFor !== 'function') {\n\t\t\t\tthrow new Error('Hypermedia response expected');\n\t\t\t}\n\t\t\tvar client = response.entity.clientFor(rel.rel);\n\t\t\treturn client({ params: rel.params });\n\t\t});\n\t}, this));\n}\n\n/**\n * Wrap a Promise as an ResponsePromise\n *\n * @param {Promise<Response>} promise the promise for an HTTP Response\n * @returns {ResponsePromise<Response>} wrapped promise for Response with additional helper methods\n */\nfunction make(promise) {\n\tpromise.status = status;\n\tpromise.headers = headers;\n\tpromise.header = header;\n\tpromise.entity = entity;\n\tpromise.follow = follow;\n\treturn promise;\n}\n\nfunction responsePromise(obj, callback, errback) {\n\treturn make(Promise.resolve(obj).then(callback, errback));\n}\n\nresponsePromise.make = make;\nresponsePromise.reject = function (val) {\n\treturn make(Promise.reject(val));\n};\nresponsePromise.promise = function (func) {\n\treturn make(new Promise(func));\n};\n\nmodule.exports = responsePromise;\n","/*\n * Copyright 2014-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\n/**\n * Add common helper methods to a client impl\n *\n * @param {function} impl the client implementation\n * @param {Client} [target] target of this client, used when wrapping other clients\n * @returns {Client} the client impl with additional methods\n */\nmodule.exports = function client(impl, target) {\n\n\tif (target) {\n\n\t\t/**\n\t\t * @returns {Client} the target client\n\t\t */\n\t\timpl.skip = function skip() {\n\t\t\treturn target;\n\t\t};\n\n\t}\n\n\t/**\n\t * Allow a client to easily be wrapped by an interceptor\n\t *\n\t * @param {Interceptor} interceptor the interceptor to wrap this client with\n\t * @param [config] configuration for the interceptor\n\t * @returns {Client} the newly wrapped client\n\t */\n\timpl.wrap = function wrap(interceptor, config) {\n\t\treturn interceptor(impl, config);\n\t};\n\n\t/**\n\t * @deprecated\n\t */\n\timpl.chain = function chain() {\n\t\tif (typeof console !== 'undefined') {\n\t\t\tconsole.log('rest.js: client.chain() is deprecated, use client.wrap() instead');\n\t\t}\n\n\t\treturn impl.wrap.apply(this, arguments);\n\t};\n\n\treturn impl;\n\n};\n","/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar UrlBuilder, responsePromise, client;\n\nUrlBuilder = require('../UrlBuilder');\nresponsePromise = require('../util/responsePromise');\nclient = require('../client');\n\n// consider abstracting this into a util module\nfunction clearProperty(scope, propertyName) {\n\ttry {\n\t\tdelete scope[propertyName];\n\t}\n\tcatch (e) {\n\t\t// IE doesn't like to delete properties on the window object\n\t\tif (propertyName in scope) {\n\t\t\tscope[propertyName] = void 0;\n\t\t}\n\t}\n}\n\nfunction cleanupScriptNode(response) {\n\ttry {\n\t\tif (response.raw && response.raw.parentNode) {\n\t\t\tresponse.raw.parentNode.removeChild(response.raw);\n\t\t}\n\t} catch (e) {\n\t\t// ignore\n\t}\n}\n\nfunction registerCallback(prefix, resolve, response, name) {\n\tif (!name) {\n\t\tdo {\n\t\t\tname = prefix + Math.floor(new Date().getTime() * Math.random());\n\t\t}\n\t\twhile (name in window);\n\t}\n\n\twindow[name] = function jsonpCallback(data) {\n\t\tresponse.entity = data;\n\t\tclearProperty(window, name);\n\t\tcleanupScriptNode(response);\n\t\tif (!response.request.canceled) {\n\t\t\tresolve(response);\n\t\t}\n\t};\n\n\treturn name;\n}\n\n/**\n * Executes the request as JSONP.\n *\n * @param {string} request.path the URL to load\n * @param {Object} [request.params] parameters to bind to the path\n * @param {string} [request.callback.param='callback'] the parameter name for\n *   which the callback function name is the value\n * @param {string} [request.callback.prefix='jsonp'] prefix for the callback\n *   function, as the callback is attached to the window object, a unique,\n *   unobtrusive prefix is desired\n * @param {string} [request.callback.name=<generated>] pins the name of the\n *   callback function, useful for cases where the server doesn't allow\n *   custom callback names. Generally not recommended.\n *\n * @returns {Promise<Response>}\n */\nmodule.exports = client(function jsonp(request) {\n\treturn responsePromise.promise(function (resolve, reject) {\n\n\t\tvar callbackName, callbackParams, script, firstScript, response;\n\n\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\tresponse = { request: request };\n\n\t\tif (request.canceled) {\n\t\t\tresponse.error = 'precanceled';\n\t\t\treject(response);\n\t\t\treturn;\n\t\t}\n\n\t\trequest.callback = request.callback || {};\n\t\tcallbackName = registerCallback(request.callback.prefix || 'jsonp', resolve, response, request.callback.name);\n\t\tcallbackParams = {};\n\t\tcallbackParams[request.callback.param || 'callback'] = callbackName;\n\n\t\trequest.canceled = false;\n\t\trequest.cancel = function cancel() {\n\t\t\trequest.canceled = true;\n\t\t\tcleanupScriptNode(response);\n\t\t\treject(response);\n\t\t};\n\n\t\tscript = document.createElement('script');\n\t\tscript.type = 'text/javascript';\n\t\tscript.async = true;\n\t\tscript.src = response.url = new UrlBuilder(request.path, callbackParams).build();\n\n\t\tfunction handlePossibleError() {\n\t\t\tif (typeof window[callbackName] === 'function') {\n\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\tclearProperty(window, callbackName);\n\t\t\t\tcleanupScriptNode(response);\n\t\t\t\treject(response);\n\t\t\t}\n\t\t}\n\t\tscript.onerror = function () {\n\t\t\thandlePossibleError();\n\t\t};\n\t\tscript.onload = script.onreadystatechange = function (e) {\n\t\t\t// script tag load callbacks are completely non-standard\n\t\t\t// handle case where onreadystatechange is fired for an error instead of onerror\n\t\t\tif ((e && (e.type === 'load' || e.type === 'error')) || script.readyState === 'loaded') {\n\t\t\t\thandlePossibleError();\n\t\t\t}\n\t\t};\n\n\t\tresponse.raw = script;\n\t\tfirstScript = document.getElementsByTagName('script')[0];\n\t\tfirstScript.parentNode.insertBefore(script, firstScript);\n\n\t});\n});\n","import { map, now, runEffects, filter, fromPromise, debounce, skipRepeats, switchLatest, tap } from '@most/core'\nimport { newDefaultScheduler } from '@most/scheduler'\nimport { input } from '@most/dom-event'\nimport { partition, mapEither, unpartition } from 'most-product'\nimport rest from 'rest/client/jsonp'\n\nconst url = 'https://en.wikipedia.org/w/api.php?action=opensearch&format=json&search='\n\nconst search = document.getElementById('search')\nconst resultList = document.getElementById('results')\nconst template = document.getElementById('template').innerHTML\n\n// Fetch results with rest.js\n// Returns a promise for the wikipedia json response\nconst getResults = text => rest(url + text).entity()\n\n// Get input value when it changes\n// Multicast the stream as it's later being merged by an observer\nconst searchText = input(search) |>\n  map(e => e.target.value.trim()) |>\n  skipRepeats |>\n  debounce(500)\n\n// Get results from wikipedia API and render\n// Only search if the user stopped typing for 500ms\n// and is different than the last time we saw the text\n// Ignore empty results, extract and return the actual\n// list of results from the wikipedia payload\nconst results = searchText |>\n  filter(text => text.length > 1) |>\n  map(getResults) |>\n  map(fromPromise) |>\n  switchLatest |>\n  partition(results => results.length > 1) |>\n  mapEither(_ => [], results => results[1]) |>\n  unpartition\n\nconst render = resultContent => {\n  resultList.innerHTML = resultContent.reduce(\n    (html, item) => html + template.replace(/\\{name\\}/g, item), ''\n  )\n}\n\n// Render the results\nrunEffects(tap(render, results), newDefaultScheduler())\n"],"names":["l","a","b","i","f","r","unsafeRemove","j","x","ScheduledTask","run","error","e","dispose","const","scheduler","tryEvent","currentTime","this","fatalError","rethrow","curry2","arguments","curry3","empty","mixin","dest","source","name","length","module","encodedSpaceRE","urlEncodedSpaceRE","urlEncode","str","encodeURIComponent","replace","urlDecode","decodeURIComponent","append","value","Array","isArray","forEach","undefined","obj","split","entry","pair","push","keys","xWWWFormURLEncoder","origin","urlRE","absoluteUrlRE","fullyQualifiedUrlRE","require","buildUrl","template","params","url","queryStringParams","queryString","re","RegExp","test","write","indexOf","startsWith","UrlBuilder","_template","_params","toString","prototype","location","isFullyQualified","protocol","isAbsolute","pathname","substring","lastIndexOf","build","parts","hostname","port","fullyQualify","match","host","href","normalizeHeaderName","toLowerCase","map","chunk","charAt","toUpperCase","slice","join","property","promise","then","Promise","reject","entity","status","headers","header","headerName","follow","rels","concat","make","reduce","response","rel","clientFor","Error","client","responsePromise","callback","errback","resolve","val","func","impl","target","skip","wrap","interceptor","config","chain","console","log","apply","clearProperty","scope","propertyName","cleanupScriptNode","raw","parentNode","removeChild","registerCallback","prefix","Math","floor","Date","getTime","random","window","jsonpCallback","data","request","canceled","jsonp","callbackName","callbackParams","script","firstScript","param","cancel","document","createElement","type","async","src","path","handlePossibleError","onerror","onload","onreadystatechange","readyState","getElementsByTagName","insertBefore","search","getElementById","resultList","innerHTML","getResults","rest","text","searchText","input","trim","skipRepeats","debounce","results","filter","fromPromise","switchLatest","partition","mapEither","unpartition","render","resultContent","html","item","runEffects","tap","newDefaultScheduler"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}